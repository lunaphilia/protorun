# Cline Rules

## 1. Project Philosophy & Design
- 言語設計は関数型プログラミング、強力な型システム、メモリ安全性の統合を重視する。
- 代数的効果と所有権モデルを組み合わせた独自のアプローチを採用する。
- Scala、Haskell、Rustからインスピレーションを得た言語機能を参考にする。
- パーサー実装にはNomパーサーコンビネータライブラリを使用し、宣言的で効率的な構文解析を目指す。

## 2. Development Process & Testing
- 段階的な実装アプローチ（インタープリタから始め、徐々にコンパイラ機能を追加）を採用する。
- テスト駆動開発（TDD）を実践する。
    - プロダクションコードを小さく修正し、こまめにテストコードを書き、テストが通ることを確認してから次の修正を行う。
    - テストは関数単位で書き、ボトムアップに振る舞いの正しさを確認する。大きな振る舞いのテストでは、部品関数をモック化しても良い。
    - テスト失敗時は、デバッグコードを追加して出力された事実から原因を特定し、的確かつ簡潔に修正する。
- 言語仕様の詳細化と形式化を進める。
- 実装を変更した際は関連する言語仕様（ドキュメント）も修正し、逆に仕様を変更した際は関連する実装も修正することで、両者の整合性を常に保つ。
- 計画や実装において複数の選択肢が考えられる場合は、自己判断で進めずにユーザーに選択肢を提示し、指示を仰ぐ。
- コードを整理・簡素化し、使用されていないコードは削除する。
- 結合度が低く、凝集度が高い構造に継続的にリファクタリングする。
- タスク進行中に明らかになった一般的な注意点や指摘事項は、既存ルールと矛盾なく簡潔に`.clinerules`へ追記する。

## 3. Implementation Guidelines
- 関数型プログラミングスタイルを優先し、副作用を最小限に抑える。
- 型安全性を重視したコード設計を行う。
- Nomパーサーコンビネータを使用し、宣言的な構文解析を実装する。
- 比較演算子のパースでは、`<=`, `>=`のような2文字演算子を`,` `<`のような1文字演算子より先に試す。
- エラーメッセージにはコンテキスト情報を含め、ユーザーにとって理解しやすいものにする。

## 4. Git Workflow & Communication
- コミュニケーションは日本語で行う。
- コミットは、論理的な変更単位（機能の一部、バグ修正、リファクタリング、テスト追加など）で行う。
- TDDのサイクルに合わせ、テストが通る小さな変更単位でコミットすることを推奨する。
- コミットメッセージは英語で、変更内容を明確に記述する (`feat:`, `fix:`, `refactor:`, `test:`, `docs:`, `chore:` などのプレフィックスを使用することを推奨)。
- コマンドは一度に一つずつ実行し、`&&` などで連結しない。
- (注: 現在は主に`master`/`main`ブランチで開発を進める。将来的に複数人開発体制になった際にブランチ戦略を見直す。)

## 5. Known Challenges
- 言語機能の複雑さとシンプルさのバランス。
- 代数的効果と所有権システムの統合における理論的課題。
- 型推論、効果推論、所有権推論の相互作用。
- パーサーの性能最適化（大規模なソースコードの解析時）。
- エラーメッセージの改善（より具体的で役立つ情報の提供）。
