# システムパターン

## アーキテクチャ概要
Protorun言語は、関数型プログラミング、強力な型システム、メモリ安全性を統合したプログラミング言語として設計されています。言語の実装はコンパイラフロントエンド、中間表現（IR）、バックエンドの3層アーキテクチャに基づいています。

## 主要コンポーネント

### 言語コア
- **字句解析器・構文解析器**: ソースコードを抽象構文木（AST）に変換
- **型チェッカー**: 静的型チェックと型推論を実行
- **効果システム**: 代数的効果の追跡と検証
- **所有権チェッカー**: メモリ安全性を保証する所有権と借用の検証

### 中間表現（IR）
- **IR生成**: ASTから中間表現への変換
- **最適化パス**: IR上での各種最適化
- **効果変換**: 代数的効果のCPS（継続渡しスタイル）変換

### バックエンド
- **インタープリタ**: IR直接実行エンジン
- **コードジェネレータ**: ネイティブコード生成
- **ランタイムシステム**: メモリ管理、効果ハンドラ実行環境

## 設計パターン

### 型システム
- **代数的データ型**: enum構文による簡潔な定義
- **型クラス**: Haskellスタイルの型クラスによる多相性
- **型推論**: Hindley-Milner型推論の拡張
- **Option/Result型**: nullの排除と安全なエラー処理
- **継承の最小化**: トレイトの単一継承のみをサポート

### 効果システム
- **代数的効果**: 型安全な副作用の表現と制御
- **効果ハンドラ**: 効果の実装と合成
- **効果推論**: 関数の効果を自動的に推論
- **効果スコープ**: 効果の局所的な使用のためのwith式
- **関数合成**: パイプライン演算子と関数合成演算子による見通しのよいコード
- **効果ローカライゼーション**: local effect構文による効果の伝播制限
- **効果の型安全性**: 効果の型レベルでの追跡と検証

### メモリ管理
- **所有権モデル**: Rustスタイルの所有権と借用
- **ライフタイム**: 参照の有効期間の静的検証
- **管理型**: 自動リソース管理のための管理型（旧リソース型）
- **ライフサイクル管理効果**: 効果システムとリソース管理の統合

### リソース管理パターン
- **ライフサイクル管理効果パターン**:
  - effect with lifecycle構文による効果とリソース管理の統合
  - with cleanup機能によるリソースライフサイクルの自動管理
  - fn cleanup構文による解放操作の標準化
- **管理リソースパターン型クラス**:
  - Resource<R>型クラスによるリソース操作の抽象化
  - 管理型に対する自動実装機能
  - リソース変換と合成のパターン
- **コンテキスト型**:
  - context type構文による暗黙的なコンテキスト渡し
  - 依存性注入パターンの自然な実装
  - スコープベースのリソースライフサイクル管理
- **所有権を考慮した効果**:
  - ownキーワードによる所有権の明示
  - 効果操作における所有権の移動と借用の制御
  - リソースライフタイムと効果スコープの統合

### 制御フロー
- **式ベースの設計**: すべての制御構造は値を返す式として実装
- **パターンマッチング**: 代数的データ型の分解と条件分岐の統合
- **二重制御構造**: if式とmatch式の両方を維持
  - if式: 単純な条件分岐と複合条件に最適化
  - match式: パターンマッチングと網羅性チェックに最適化
- **ガード条件**: パターンとガード条件を組み合わせた分岐

## 技術的決定

### 言語設計
- **静的型付け**: コンパイル時の型エラー検出
- **型推論**: 明示的な型注釈の最小化
- **純粋関数の推奨**: 副作用を効果システムで明示的に制御
- **パターンマッチング**: 代数的データ型の分解と条件分岐の統合
- **nullの排除**: 値の存在/不在はOption型で表現
- **関数合成**: パイプライン演算子と関数合成演算子による関数型スタイル
- **制御構造の二重性**: 状況に応じた適切なツール選択（if式/match式）を可能に
- **リソース管理の統合**: リソース型と効果システムの統合的なアプローチ
- **コンテキスト管理**: 暗黙的なコンテキスト渡しの仕組み

### 実装アプローチ
- **段階的実装**: インタープリタから始め、徐々にコンパイラ機能を追加
- **自己ホスティング**: 最終的に言語自身で実装
- **モジュラー設計**: コンポーネントの明確な分離と再利用性
- **バックエンドオプション**: インタープリタによる直接実行とLLVMによるネイティブコード生成
- **効果変換**: 効果操作のCPS変換による効率的な実装
- **リソース最適化**: リソース管理のオーバーヘッド最小化
