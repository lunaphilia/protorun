# システムパターン

## アーキテクチャ概要
Protorun言語は、関数型プログラミング、強力な型システム、メモリ安全性を統合したプログラミング言語として設計されています。言語の実装はコンパイラフロントエンド、中間表現（IR）、バックエンドの3層アーキテクチャに基づいています。

## 主要コンポーネント

### 言語コア
- **字句解析器・構文解析器**: ソースコードを抽象構文木（AST）に変換
- **型チェッカー**: 静的型チェックと型推論を実行
- **効果システム**: 代数的効果の追跡と検証
- **所有権チェッカー**: メモリ安全性を保証する所有権と借用の検証

### 中間表現（IR）
- **IR生成**: ASTから中間表現への変換
- **最適化パス**: IR上での各種最適化
- **効果変換**: 代数的効果のCPS（継続渡しスタイル）変換

### バックエンド
- **インタープリタ**: IR直接実行エンジン
- **コードジェネレータ**: ネイティブコード生成
- **ランタイムシステム**: メモリ管理、効果ハンドラ実行環境

## 設計パターン

### 型システム
- **代数的データ型**: enum構文による簡潔な定義
- **型クラス**: Haskellスタイルの型クラスによる多相性
- **型推論**: Hindley-Milner型推論の拡張
- **Option/Result型**: nullの排除と安全なエラー処理
- **継承の最小化**: トレイトの単一継承のみをサポート

### 効果システム
- **代数的効果**: 型安全な副作用の表現と制御
- **効果ハンドラ**: 効果の実装と合成
- **効果推論**: 関数の効果を自動的に推論
- **効果スコープ**: 効果の局所的な使用のためのwith式
- **関数合成**: パイプライン演算子と関数合成演算子による見通しのよいコード
- **効果スコープ制限**: `with scoped`構文による効果の伝播制限
- **効果の型安全性**: 効果の型レベルでの追跡と検証

### メモリ管理
- **所有権モデル**: Rustスタイルの所有権と借用
- **ライフタイム**: 参照の有効期間の静的検証
- **ライフサイクル管理効果**: 効果システムとリソース管理の統合

### リソース管理パターン
- **ライフサイクル管理効果パターン**:
  - `LifecycleEffect<R>`型による効果とリソース管理の統合
  - `acquire`と`release`操作によるリソースライフサイクルの自動管理
  - スコープベースのリソース解放の自動化
- **暗黙的パラメータによる依存性注入**:
  - `(with param: Type)`構文による暗黙的なパラメータ渡し
  - 依存性注入パターンの型安全な実装
  - スコープベースの依存性提供
- **所有権を考慮した効果**:
  - `own`キーワードによる所有権の明示
  - 効果操作における所有権の移動と借用の制御
  - リソースライフタイムと効果スコープの統合

### 制御フロー
- **式ベースの設計**: すべての制御構造は値を返す式として実装
- **パターンマッチング**: 代数的データ型の分解と条件分岐の統合
- **二重制御構造**: if式とmatch式の両方を維持
  - if式: 単純な条件分岐と複合条件に最適化
  - match式: パターンマッチングと網羅性チェックに最適化
- **ガード条件**: パターンとガード条件を組み合わせた分岐
- **コレクション内包表記**: Pythonスタイルのリスト内包表記による簡潔なコレクション操作
- **bind式**: モナド連鎖のための専用構文
- **return文**: 関数からの早期リターンを実現するための命令型スタイル制御構文（代数的効果による代替ではなく、専用構文として維持）。

### 文書化パターン
- **責任分離**: 各文書は特定の側面に焦点を当て、他の文書と重複しない
  - 文法ファイル: 言語の構文を形式的に定義
  - 型システム文書: 型の意味論と型チェックルール
  - 宣言の文書: 名前と実体の導入（変数、関数、型など）
  - 文の文書: 副作用や制御フローの実行（式文、return文など）
  - 式の文書: 値の計算と評価規則
  - 所有権文書: メモリ安全性の保証メカニズム
  - 効果システム文書: 副作用の制御と効果ハンドラ
- **相互参照**: 詳細な説明は一箇所にのみ記述し、他の文書からは参照
  - 各文書は自身の責任範囲に集中
  - 関連する詳細は適切な文書への参照を提供
  - 重複を避け、一貫性を確保
- **現在の状態と意義**: 仕様書は過去の経緯ではなく現在の状態と意義に焦点
  - 現在の言語機能と構文を正確に記述
  - 各機能の設計意図と利点を説明
  - 廃止された構文や機能は記載しない
- **簡潔性と完全性のバランス**: 必要十分な情報を提供
  - 簡潔で明確な説明
  - 必要な詳細はすべて含める
  - 冗長な説明を避ける
- **一貫した用語と表記**: 文書全体で統一された用語と表記を使用
  - 型注釈パターン「エンティティ: 型」の一貫した使用
  - 効果注釈「ReturnType & Effect」の統一
  - 構文要素の命名の一貫性

## 技術的決定

### 言語設計
- **静的型付け**: コンパイル時の型エラー検出
- **型推論**: 明示的な型注釈の最小化
- **純粋関数の推奨**: 副作用を効果システムで明示的に制御
- **パターンマッチング**: 代数的データ型の分解と条件分岐の統合
- **nullの排除**: 値の存在/不在はOption型で表現
- **関数合成**: パイプライン演算子と関数合成演算子による関数型スタイル
- **制御構造の二重性**: 状況に応じた適切なツール選択（if式/match式）を可能に
- **リソース管理の統合**: リソース型と効果システムの統合的なアプローチ
- **コンテキスト管理**: 暗黙的なコンテキスト渡しの仕組み

### 実装アプローチ
- **段階的実装**: インタープリタから始め、徐々にコンパイラ機能を追加
- **自己ホスティング**: 最終的に言語自身で実装
- **モジュラー設計**: コンポーネントの明確な分離と再利用性
- **バックエンドオプション**: インタープリタによる直接実行とLLVMによるネイティブコード生成
- **効果変換**: 効果操作のCPS変換による効率的な実装
- **リソース最適化**: リソース管理のオーバーヘッド最小化

### パーサー実装
- **Nomパーサーコンビネータ**: 宣言的で効率的な構文解析
- **モジュラー構造**: 機能別にモジュール分割された構文解析器
- **マルチパスアプローチ**: 
  - 最初のパスでASTを構築し、その後の別のパスでコンテキスト情報（スコープなど）を処理
  - パーサー関数はコンテキスト情報を引き回さず、純粋に構文解析に集中
  - コンテキスト情報（シンボルテーブルなど）は別のパスで処理することで、パーサーの実装をシンプルに保つ
  - 各パーサー関数は入力文字列と元の入力文字列のみを受け取り、パース結果と残りの入力文字列を返す純粋な形式を維持
- **エラーメッセージの充実**: コンテキスト情報を含む詳細なエラーメッセージ
- **スパン情報の追跡**: ソースコード位置情報の正確な追跡
- **シンボルテーブルとの統合**: スコープ管理と名前解決の統合（別パスで実行）

### シンボルテーブル設計
- **スコープの階層構造**: グローバル、モジュール、関数、ブロック、ループの階層
- **シンボルの種類**: 変数、関数、型、パラメータの区別
- **型情報の管理**: シンボルに関連付けられた型情報の保持
- **使用状態の追跡**: シンボルの使用状態を追跡し、未使用シンボルを検出
- **親スコープへの遡及検索**: 名前解決のための階層的な検索メカニズム
