# システムパターン

## アーキテクチャ概要
Protorun言語は、関数型プログラミング、強力な型システム、メモリ安全性を統合したプログラミング言語として設計されています。言語の実装はコンパイラフロントエンド、中間表現（IR）、バックエンドの3層アーキテクチャに基づいています。

## 主要コンポーネント

### 言語コア
- **字句解析器・構文解析器**: ソースコードを抽象構文木（AST）に変換
- **型チェッカー**: 静的型チェックと型推論を実行
- **効果システム**: 代数的効果の追跡と検証
- **所有権チェッカー**: メモリ安全性を保証する所有権と借用の検証

### 中間表現（IR）
- **IR生成**: ASTから中間表現への変換
- **最適化パス**: IR上での各種最適化
- **効果変換**: 代数的効果のCPS（継続渡しスタイル）変換

### バックエンド
- **インタープリタ**: IR直接実行エンジン
- **コードジェネレータ**: ネイティブコード生成
- **ランタイムシステム**: メモリ管理、効果ハンドラ実行環境

## 設計パターン

### 型システム
- **代数的データ型**: Scalaスタイルのシールドトレイトとケースクラス
- **型クラス**: Haskellスタイルの型クラスによる多相性
- **型推論**: Hindley-Milner型推論の拡張

### 効果システム
- **代数的効果**: 型安全な副作用の表現と制御
- **効果ハンドラ**: 効果の実装と合成
- **効果推論**: 関数の効果を自動的に推論

### メモリ管理
- **所有権モデル**: Rustスタイルの所有権と借用
- **ライフタイム**: 参照の有効期間の静的検証
- **リソース管理**: RAIIパターンと効果の統合

## 技術的決定

### 言語設計
- **静的型付け**: コンパイル時の型エラー検出
- **型推論**: 明示的な型注釈の最小化
- **純粋関数の推奨**: 副作用を効果システムで明示的に制御
- **パターンマッチング**: 代数的データ型の分解と条件分岐の統合

### 実装アプローチ
- **段階的実装**: インタープリタから始め、徐々にコンパイラ機能を追加
- **自己ホスティング**: 最終的に言語自身で実装
- **モジュラー設計**: コンポーネントの明確な分離と再利用性
