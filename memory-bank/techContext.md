# 技術コンテキスト

## 技術スタック

### 言語実装の選択
- **実装言語**
  - **Rust**: メモリ安全性と高性能、強力な型システム、LLVMとの統合が容易
- **ビルドツール**: Cargo（Rustのパッケージマネージャとビルドシステム）
- **パーサー技術**
  - **Nomパーサーコンビネータ**: 宣言的な構文、モジュラー性、型安全性、エラー処理の柔軟性

### 開発ツール
- **バージョン管理**: Git
- **CI/CD**: GitHub Actions
- **テストフレームワーク**: 
  - 単体テスト（Rust標準のテストフレームワーク）
  - プロパティベーステスト（proptest）
  - 統合テスト
- **文書化ツール**:
  - **Markdown**: 言語仕様書、設計文書、メモリーバンクの記述
  - **EBNF**: 形式的な文法定義
  - **図表生成**: Mermaid（アーキテクチャ図、型階層図）
  - **相互参照システム**: 文書間のリンクと参照管理

### バックエンドオプション
- **インタープリタ**: IR直接実行エンジン（現在の実装フォーカス）
- **LLVM**: 最適化パスの豊富さ、多くのターゲットアーキテクチャ、成熟したエコシステム（将来の計画）
- **カスタムバイトコード + VM**: 完全な制御、言語固有の最適化（代替オプション）

### ターゲット環境
- **インタープリタ**: 独自VM上での実行
- **コンパイラ**: LLVM IRへの変換とネイティブコード生成（将来の計画）
- **クロスプラットフォーム**: Linux, macOS, Windowsをサポート

## 開発環境

### 必要なツール
- **Rustツールチェーン**: rustc, cargo, rustfmt, clippy
- **エディタ/IDE**: VSCode（rust-analyzer拡張機能）
- **デバッガ**: GDB/LLDB, VSCodeデバッグ機能

### 環境セットアップ
1. Rustツールチェーンのインストール（rustup経由）
2. 依存ライブラリのインストール（Cargo.tomlに記述）
3. テスト環境の構築（cargo testコマンド）

### 開発ワークフロー（段階的アプローチ）
#### 段階1: 言語設計と基本実装（現在の段階）
1. 言語仕様の詳細化と形式化
   - 構文の形式的定義（EBNF）
   - 型システムの規則の定義
   - 評価規則の定義
   - 文書化プロセスの確立
2. フロントエンド実装
   - 構文解析器の実装（Nomパーサーコンビネータを使用）
   - 抽象構文木（AST）の定義
   - シンボルテーブルの実装
3. 型システム実装（次のステップ）
   - 型チェッカーの実装
   - 型推論アルゴリズムの実装
   - 基本的な型エラー報告

#### 段階2: 高度な機能と最適化
1. 代数的効果システム実装
   - 効果型の実装
   - 効果推論の実装
   - 効果ハンドラの実装
   - 継続渡しスタイル（CPS）変換
2. 所有権システム実装
   - 所有権チェッカーの実装
   - 借用チェッカーの実装
   - ライフタイム解析の実装
   - メモリ安全性検証
3. インタープリタ実装
   - 評価器の実装
   - 基本的なランタイムシステム
   - プリミティブ操作の実装
4. 標準ライブラリ実装
   - 基本データ型（Int, Float, String, Bool）
   - コレクション（List, Map, Set）
   - 基本的なI/O操作

#### 段階3: ツールとエコシステム
1. コンパイラバックエンド
   - LLVM IRへの変換
   - ネイティブコード生成
   - 最適化パスの統合
   - クロスプラットフォームサポート
2. 開発ツール
   - REPLの実装
   - デバッガの実装
   - パッケージマネージャの設計と実装
   - ビルドシステムの実装
3. IDE統合
   - 言語サーバープロトコル（LSP）の実装
   - シンタックスハイライト
   - コード補完
   - リファクタリングサポート
4. ドキュメントとチュートリアル
   - 言語リファレンスマニュアル
   - チュートリアルと例
   - APIドキュメント
   - ベストプラクティスガイド

### 文書化プロセス
1. **言語仕様書の作成と更新**
   - 仕様書は現在の状態と、その仕様としている意義を中心に記述
   - 実装前に仕様を文書化し、設計の一貫性を確保
   - 他の文書で解説されている内容を重複して記述しない
   - 過去の経緯や廃止された構文に関する情報は記載しない

2. **文書間の一貫性確保**
   - 文書間の参照を適切に行い、重複を避ける
   - 各文書は自身の責任範囲に集中し、他の文書の内容を参照する
   - 用語集を維持し、用語の一貫した使用を確保
   - 定期的な文書レビューを実施し、矛盾や重複を排除

3. **文書の構造化**
   - 階層的な構造で情報を整理（章、節、項）
   - 各文書の責任範囲を明確に定義
   - 簡潔で一貫性のある記述を心がける
   - 文法ファイルは言語の構文を形式的に定義することに集中し、詳細な説明は他の文書に委ねる

4. **一貫した用語と表記**
   - 型注釈パターン「エンティティ: 型」の一貫した使用
   - 効果注釈「ReturnType & Effect」の統一
   - 構文要素の命名の一貫性

## 依存関係

### コア依存関係
- **nom**: パーサーコンビネータライブラリ（構文解析）
- **thiserror**: エラー型の定義と処理
- **anyhow**: エラーハンドリング
- **proptest**: プロパティベーステスト

### 開発依存関係
- **Rustテストフレームワーク**: 単体テスト、統合テスト
- **rustfmt**: コードフォーマッタ
- **clippy**: リンター

### 標準ライブラリ（計画）
- **コアデータ構造**: リスト、マップ、セットなど
- **Option/Result型**: 値の存在/不在と成功/失敗の表現
- **I/O操作**: ファイル、ネットワーク、コンソール
- **並行処理**: スレッド、非同期処理
- **数値計算**: 整数、浮動小数点、ビット操作
- **ライフサイクル管理効果**: ファイル、ネットワーク接続、データベース接続などのリソース管理
- **効果ハンドラ**: 標準効果（Console、IO、State、Exception、LifecycleEffectなど）の実装

## 技術的制約

### パフォーマンス要件
- **コンパイル時間**: 大規模プロジェクトでも合理的なコンパイル時間
- **実行時パフォーマンス**: C/Rust/Goに匹敵する実行速度
- **メモリ使用量**: 効率的なメモリ使用と予測可能なリソース管理
- **効果ハンドラのオーバーヘッド**: 最小限に抑える

### 安全性要件
- **型安全性**: 強力な静的型チェック
- **メモリ安全性**: 所有権システムによるメモリエラーの防止
- **スレッド安全性**: データ競合の静的検出
- **nullの排除**: nullポインタ例外の可能性を排除
- **リソース安全性**: リソースリークの静的防止

### 互換性要件
- **FFI**: C言語とのインターフェース
- **エコシステム**: 既存のライブラリやツールとの統合
- **プラットフォーム**: 主要OSとアーキテクチャのサポート

## 現在のマイルストーン計画

### マイルストーン1: 言語仕様の完成（目標：2025年4月末）
- 言語仕様書の完成
- 文法の完全な形式化
- 標準ライブラリの仕様完成

### マイルストーン2: プロトタイプインタープリタの実装（目標：2025年6月末）
- 基本的な構文解析（完了）
- 型チェック
- 効果推論
- 所有権チェック
- 簡単なプログラムの実行

### マイルストーン3: コンパイラの基本機能実装（目標：2025年9月末）
- 中間表現（IR）の設計と実装
- 最適化パスの実装
- バックエンドの選定と実装

### マイルストーン4: 言語ツールの開発（目標：2025年12月末）
- LSP（Language Server Protocol）の実装
- デバッガの実装
- パッケージマネージャの実装
