// Protorun言語サンプル: 簡単な計算機

// 式を表す代数的データ型（enum構文）
enum Expr {
  Number(Int),
  Add(Expr, Expr),
  Subtract(Expr, Expr),
  Multiply(Expr, Expr),
  Divide(Expr, Expr)
}

// 例外効果
effect Exception<E> {
  fn raise<T>(error: E): T
}

// 例外ハンドラ
fn runException<T, E>(action: () -> T with Exception<E>): Result<T, E> = {
  handle action() {
    return x => Result.Ok(x),
    
    Exception.raise(error) => Result.Err(error)
  }
}

// 式の評価
fn evaluate(expr: Expr): Int with Exception<String> = {
  match expr {
    Expr.Number(value) => value,
    
    Expr.Add(left, right) => {
      let l = evaluate(left)
      let r = evaluate(right)
      l + r
    },
    
    Expr.Subtract(left, right) => {
      let l = evaluate(left)
      let r = evaluate(right)
      l - r
    },
    
    Expr.Multiply(left, right) => {
      let l = evaluate(left)
      let r = evaluate(right)
      l * r
    },
    
    Expr.Divide(left, right) => {
      let l = evaluate(left)
      let r = evaluate(right)
      
      if r == 0 {
        Exception.raise("ゼロ除算エラー")
      } else {
        l / r
      }
    }
  }
}

// コンソール効果
effect Console {
  fn log(message: String): Unit
  fn readLine(): String
}

// コンソールハンドラ
fn runConsole<T>(action: () -> T with Console): T = {
  handle action() {
    Console.log(message) => {
      println(message)
      resume()
    },
    
    Console.readLine() => {
      let input = readLine()
      resume(input)
    }
  }
}

// 文字列をパースして式に変換
fn parseExpr(input: String): Result<Expr, String> = {
  // 実際の実装では、より複雑なパーサーを使用
  // ここでは簡略化のため、単純な例を示す
  try {
    let tokens = input.split(" ")
    
    if tokens.length == 1 {
      // toInt()はOption<Int>を返すように変更
      match tokens[0].toInt() {
        Option.Some(value) => Result.Ok(Expr.Number(value)),
        Option.None => Result.Err("数値への変換エラー")
      }
    } else if tokens.length == 3 {
      // 両方の数値を変換
      let leftNum = tokens[0].toInt()
      let rightNum = tokens[2].toInt()
      
      match (leftNum, rightNum) {
        (Option.Some(l), Option.Some(r)) => {
          let left = Expr.Number(l)
          let right = Expr.Number(r)
          let op = tokens[1]
          
          match op {
            "+" => Result.Ok(Expr.Add(left, right)),
            "-" => Result.Ok(Expr.Subtract(left, right)),
            "*" => Result.Ok(Expr.Multiply(left, right)),
            "/" => Result.Ok(Expr.Divide(left, right)),
            _ => Result.Err(s"不明な演算子: $op")
          }
        },
        _ => Result.Err("数値への変換エラー")
      }
    } else {
      Result.Err("無効な入力形式")
    }
  } catch {
    _ => Result.Err("パースエラー")
  }
}

// メイン関数
fn main(): Unit with Console = {
  Console.log("簡単な計算機")
  Console.log("形式: 数値 演算子 数値（例: 5 + 3）")
  Console.log("終了するには 'exit' と入力してください")
  
  var running = true
  
  while running {
    Console.log("> ")
    let input = Console.readLine()
    
    if input == "exit" {
      running = false
      Console.log("終了します")
    } else {
      // パイプライン演算子を使用した処理
      input
        |> parseExpr
        |>* processExprResult
    }
  }
}

// 式の結果を処理する関数
fn processExprResult(result: Result<Expr, String>): Unit with Console = {
  match result {
    Result.Ok(expr) => {
      // 効果スコープを使用
      with Exception<String> {
        try {
          let value = evaluate(expr)
          Console.log(s"結果: $value")
        } catch (error) {
          Console.log(s"評価エラー: $error")
        }
      }
    },
    
    Result.Err(error) => {
      Console.log(s"パースエラー: $error")
    }
  }
}

// プログラム実行
fn run(): Unit = {
  // 効果スコープを使用
  with Console handled by runConsole {
    main()
  }
}
