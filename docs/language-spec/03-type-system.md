# 3. 型システム

## 3.1 型システムの概要と目的

Protorun言語の型システムは、静的型付け、強力な型推論、代数的データ型、トレイト（型クラス）、および所有権を組み合わせた包括的なシステムです。この型システムは以下の目的で設計されています：

1. **安全性**: コンパイル時に型エラーを検出し、実行時エラーを防止します
2. **表現力**: 複雑な概念を型安全に表現するための豊富な機能を提供します
3. **抽象化**: コードの再利用と拡張を促進する抽象化メカニズムを提供します
4. **効率性**: 型消去と特殊化により、効率的なコード生成を可能にします
5. **推論可能性**: 明示的な型注釈を最小限に抑えつつ、型安全性を確保します

Protorun言語の型システムは、Hindley-Milner型推論をベースに、効果型、所有権型、トレイト制約を統合した拡張システムです。これにより、表現力と安全性のバランスを取りながら、使いやすさを実現しています。

## 3.2 基本型

```
Int, Float, Double, Bool, Char, String, Unit
```

Protorun言語の基本型は、以下の原則に基づいて設計されています：

1. **完全性**: プログラミングに必要な基本的なデータ型をすべて提供します
2. **一貫性**: 各型は明確な意味と操作を持ち、予測可能な動作をします
3. **安全性**: すべての型はnon-nullableであり、nullによる実行時エラーを防止します

特に、nullの排除は重要な設計決定です。これは、Tony Hoareが「10億ドルの間違い」と呼んだnullポインタ例外を防ぐためです。値の存在/不在はOption型で明示的に表現され、型システムによって安全に処理されます。これにより、実行時のnullチェックの必要性が減少し、コードの信頼性が向上します。

## 3.3 複合型

```
// 配列型
 [T]
 
 // 関数型
 (T1, T2, ..., Tn) -> R
 (T1, T2, ..., Tn) -> R & E

// オプション型（値の存在/不在を表現）
Option<T>

// 結果型（成功/失敗を表現）
Result<T, E>
```

Protorun言語の複合型は、以下の原則に基づいて設計されています：

1. **合成性**: 基本型から複雑な型を構築するための明確なメカニズムを提供します
2. **型安全性**: 複合型の操作は型チェックされ、型の整合性が保証されます
3. **表現力**: 様々なデータ構造と計算パターンを表現するための豊富な型を提供します

特に注目すべき点：

- **関数型の効果注釈**: 関数型には効果注釈（`& E`）を含めることができます。これにより、関数が持つ可能性のある副作用を型レベルで追跡し、型安全な効果制御を実現します。

- **Option型とResult型**: nullの代わりにOption型を使用し、例外の代わりにResult型を使用することで、エラー処理を型安全かつ明示的に行うことができます。これにより、エラーハンドリングの漏れを防ぎ、コードの堅牢性が向上します。

## 3.4 ライフサイクル管理効果

ライフサイクル管理効果は、リソースの獲得と解放を自動的に管理するための効果システムです。詳細は[8.4 ライフサイクル管理効果](08-algebraic-effects.md#84-ライフサイクル管理効果)を参照してください。

### 3.4.1 暗黙的パラメータとライフサイクル管理効果

ライフサイクル管理効果は、暗黙的パラメータとしても使用できます。これにより、依存性注入パターンを型安全かつ簡潔に実装できます。詳細は[8.8 暗黙的パラメータと効果システム](08-algebraic-effects.md#88-暗黙的パラメータと効果システム)を参照してください。
