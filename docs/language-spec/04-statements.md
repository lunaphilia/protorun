# 4. 文

## 4.1 文の概要

Protorunは式ベースの言語ですが、いくつかの構文は「文」として分類されます。文は主に副作用を引き起こすため、またはプログラムの実行フローを制御するために使用され、通常は値を返しません（ただし、ブロック式 `{...}` の最後の式は値として評価されます）。

Protorunにおける主な文の種類は以下の通りです。

- **式文 (`Expression`)**: 式を評価し、その結果を破棄します。主に副作用のために使用されます。（[4.2 式文](#42-式文-expression-statement)参照）
- **return文 (`return Expression?`)**: 現在の関数から値を返します。（[4.3 return文](#43-return文-return-statement)参照）

変数束縛のための `let` 文と `var` 文も構文上は文のように見えますが、これらは新しい名前をスコープに導入する「宣言」としての性質が強いです。そのため、これらの詳細は [3. 宣言](03-declarations.md) の章で説明します。

Protorunでは、文の終わりを示すためにセミコロンは**不要**です。通常、**改行**が文の区切りとして解釈されます。これにより、より簡潔なコード記述が可能になります。

```protorun
// 式文の例
println("Hello")

// 複数行にわたる式も改行で区切られる
let temp = 1 + 2 + // let文 (宣言)
           3 + 4
println(temp) // 式文
```

複数の文や宣言を一つのまとまりとして扱いたい場合は、**ブロック式** `{ ... }` を使用します。ブロック式はそれ自体も式であり、値を返すことができます。詳細は [5. 式](05-expressions.md#52-ブロック式) の章で説明します。

この章では、式文と `return` 文について詳しく説明します。

## 4.2 式文 (Expression Statement)

**構文:**

```ebnf
ExpressionStatement ::= Expression
```
(式の詳細な文法は [5. 式](05-expressions.md) を参照)

**意味:**

式文は、任意の式 (`Expression`) を評価し、その評価結果を破棄する文です。Protorunは式ベースの言語であり、ほとんどの構文要素は式として値を持ちますが、式文は文脈上その値が利用されず、主に副作用（Side Effect）を引き起こすために実行されるものを指します。

例えば、画面への出力、変数の変更、外部システムとの通信など、プログラムの状態や環境に影響を与える操作は副作用とみなされます。これらの操作を行う関数呼び出しなどが、式文としてよく用いられます。

式が `Unit` 型を返す場合（例えば、多くの副作用のみを目的とする関数）、その式を単独で実行することは自然に式文となります。`Unit` 型以外の値を返す式も式文として使用できますが、その場合、計算された値は利用されずに捨てられます。純粋な計算（副作用のない式、例: `1 + 2`）を式文として記述することも文法的には可能ですが、通常は意味がなく、リンターなどによって警告される可能性があります。

**具体例:**

```protorun
// println関数（Unitを返す）の呼び出しは典型的な式文
println("Hello, Protorun!")

// 可変変数の値を変更する操作も式文として使われる
var counter = 0
counter = counter + 1 // 代入式の結果 (Unit) は破棄される

// オブジェクトの状態を変更するメソッド呼び出し (仮の構文)
// let my_list = MutableList.new()
// my_list.add(10) // addメソッドがUnitを返す場合、これは式文

// 値を返す式も式文として書けるが、結果は捨てられる
1 + 2 // 計算結果の 3 は使われない
get_config_value() // 関数が値を返しても、変数に束縛しなければ破棄される
```

**`Unit` 型との関連:**

副作用のみを目的とし、意味のある値を返さない関数は、慣習的に `Unit` 型を返します。`Unit` 型は値が一つしかない型であり、「情報がない」ことを示します。このような関数呼び出しを単独で記述すると、自然に式文として扱われ、`Unit` 値は暗黙的に破棄されます。

## 4.3 return文 (Return Statement)

**構文:**

```ebnf
ReturnStatement ::= 'return' Expression?
```
(式の詳細な文法は [5. 式](05-expressions.md) を参照)

**意味:**

`return` 文は、現在の関数 (`fn`) の実行を即座に終了し、制御を関数の呼び出し元に戻します。

- `Expression` が指定されている場合、その式が評価され、その結果が関数の返り値として呼び出し元に渡されます。`return` される値の型は、関数の宣言された返り値型と一致している必要があります。
- `Expression` が省略されている場合、`Unit` 値が返り値として渡されます。これは、返り値型が `Unit` である関数で使用されます。

`return` 文は、関数の途中の任意の場所で使用でき、早期リターン（Early Return）を実現します。

**関数本体の最後の式との関係:**

Protorunの関数本体（通常はブロック式 `{...}`）では、ブロック内の最後の式が評価され、その結果が関数の暗黙的な返り値となります。`return` 文は、この暗黙的なリターンよりも優先され、関数の実行をその場で終了させます。

```protorun
fn check(x: Int): String {
  if x < 0 {
    return "Negative" // 早期リターン
  }
  // x >= 0 の場合、以下のブロックの最後の式が返る
  {
    println("Processing positive number...")
    "Non-negative" // この文字列が暗黙的な返り値となる
  }
}

fn process(): Unit { // または fn process() { ... } と書いても同じ
  println("Start processing")
  if should_stop_early() {
     return // 式を省略すると Unit を返す (早期リターン)
  }
  println("Continue processing")
  // 関数の最後に到達した場合、暗黙的に Unit が返る
}
```

**具体例:**

```protorun
// 条件に合致したら早期に値を返す
fn find_first(items: List<Int>, target: Int): Option<Int> {
  for item in items {
    if item == target {
      return Some(item) // 見つかったら即座に Some(item) を返す
    }
  }
  None // ループで見つからなければ、最後の式として None が返る
}

// Unit を返す関数での早期リターン
fn print_positive(x: Int): Unit {
  if x <= 0 {
    return // x が正でない場合は何もせずに関数を終了
  }
  println(x)
}

// ネストした関数やラムダ式からの return は、
// それを直接含む最も内側の fn で定義された関数から抜けることに注意
fn outer(): Int {
  let inner_lambda = |y: Int| -> Int {
    if y == 0 {
      // return 100 // これは outer 関数から return するのではなく、
                   // ラムダ式からの return (もし許可されるなら) か、
                   // あるいはコンパイルエラーになる可能性がある (言語仕様による)
                   // Protorun の詳細仕様では、ラムダ式からの非ローカルリターンは
                   // 効果などで明示的に扱う必要があるかもしれない。
                   // ここでは単純な fn からの return を示す。
    }
    y * 2
  }
  if some_condition() {
    return 0 // outer 関数から 0 を返す
  }
  inner_lambda(5) // outer 関数の暗黙のリターン値
}
```

**注意点:**

- `return` 文は `fn` で定義された関数の内部でのみ使用できます。トップレベルやモジュールレベルで直接使用することはできません。
- ラムダ式やクロージャ内での `return` の挙動（それが定義された関数から抜けるのか、ラムダ式自体から抜けるのか）は言語仕様で明確に定義される必要があります。多くの場合、非ローカルリターン（定義された関数から抜ける）には特別な構文や効果が必要となることがあります。Protorunにおける正確な仕様は別途確認が必要です。（現時点では、`fn` からの直接的なリターンを想定しています。）
