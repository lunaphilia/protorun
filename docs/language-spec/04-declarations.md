# 4. 宣言

## 4.1 宣言の概要

Protorun言語における宣言は、プログラムの構成要素（変数束縛、関数、型、トレイト、効果、ハンドラなど）を定義するための構文です。宣言は、新しい名前をスコープに導入し、それに紐づく実体（値、型、振る舞いなど）を定義します。

トップレベルのプログラムは、これらの宣言と式の並びで構成されます。

この章では、Protorunで利用可能な主要な宣言について説明します。具体的には以下のものが含まれます：

- **変数宣言 (`let`, `var`)**: イミュータブルまたはミュータブルな変数を束縛します。
- **関数定義 (`fn`)**: 新しい関数を定義します。
- **型定義 (`type`, `enum`)**: 新しいデータ型（レコード、代数的データ型、型エイリアス）を定義します。
- **トレイト定義 (`trait`) と実装 (`impl`)**: 型の振る舞いを定義するインターフェースとその実装を定義します。
- **効果インターフェース定義 (`effect`)**: 計算効果の操作シグネチャを定義します。
- **ハンドラ型定義 (`handler`)**: 効果インターフェースを実装し、状態を持つことができる新しい型を定義します。
- **エクスポート宣言 (`export`)**: モジュールから外部へ公開する要素を指定します。（[9. モジュール](09-modules.md) で詳述されます）

(効果とハンドラの詳細については [8. 代数的効果](08-algebraic-effects.md) を参照してください。)

## 4.2 変数宣言

### 4.2.1 概要と設計原則

Protorunでは、`let` キーワードと `var` キーワードを用いて変数（名前付きの値やメモリ領域）を宣言します。

```protorun
// 不変変数（デフォルト）
let x = 42
let y: Int = 42

// 可変変数
var counter = 0
var name: String = "John"
```

変数宣言の設計は、以下の原則に基づいています：

1. **不変性の優先**: デフォルトでは変数は不変（`let`）であり、これにより予測可能性と安全性が向上します。これは関数型プログラミングの原則に沿った設計です。不変性により、コードの理解と推論が容易になり、並行処理における安全性も向上します。
2. **明示的な可変性**: 可変性が必要な場合は `var` キーワードで明示的に宣言します。これにより、状態が変化する箇所をコード上で明確に識別できます。
3. **型推論**: 多くの場合、初期化式から変数の型が推論されるため、型注釈 (`: Type`) は省略可能です。これによりコードが簡潔になります。
4. **静的型付け**: 型注釈を省略した場合でも、すべての変数はコンパイル時に明確な型を持ちます。これにより型安全性が保証され、実行時エラーを削減します。必要に応じて明示的に型を指定することも可能です。

以下のサブセクションでは、`let` 宣言と `var` 宣言についてさらに詳しく説明します。

### 4.2.2 let宣言 (不変束縛)

`let` 宣言は、新しい**不変**な名前束縛を現在のスコープに導入します。一度 `let` で束縛された名前は、同じスコープ内で再代入することはできません。

**構文:**

```ebnf
LetDeclaration ::= 'let' Pattern (':' Type)? '=' Expression
```

- `let`: 宣言を開始するキーワード。
- `Pattern`: 束縛する名前（または複数の名前）を指定するパターン。単純な識別子だけでなく、タプルやレコードの分解束縛も可能です。（パターンの詳細は [6. 式](06-expressions.md#66-パターンマッチング) を参照）
- `(: Type)?`: **任意**の型注釈。省略された場合、型は右辺の `Expression` から推論されます。明示的に型を指定することで、意図を明確にしたり、推論だけでは決定できない型を指定したりできます。
- `= Expression`: 束縛する値を計算する初期化式。`let` 宣言では**初期化は必須**です。

**意味:**

`let` 宣言は以下の動作を行います。

1. 右辺の `Expression` を評価します。
2. 評価結果の値と左辺の `Pattern` をマッチングさせます。
3. マッチングが成功した場合、パターン内の各識別子が評価結果の値（またはその一部）に束縛されます。
4. 束縛された名前は、宣言された時点から現在のスコープの終わりまで有効です。
5. 束縛された名前は不変であり、後から別の値を代入することはできません。

**具体例:**

```protorun
// 単純な束縛
let message = "Hello" // 型は String と推論される
let count: Int = 100   // 型を明示的に指定

// count = 200 // エラー: let束縛は不変であり再代入できない

// パターンによる分解束縛
let point = (10, 20) // point は (Int, Int) 型と推論される
let (x, y) = point   // x に 10, y に 20 が束縛される

// レコードの分解束縛 (仮の構文)
// type Person = { name: String, age: Int }
// let person = Person { name: "Alice", age: 30 }
// let { name: person_name, age } = person // person_name に "Alice", age に 30 が束縛される

// 型注釈と初期化
let pi: Float = 3.14159
let maybe_value: Option<Int> = Some(42)

// スコープ
fn example_scope() {
  let outer = "Outer scope"
  {
    let inner = "Inner scope"
    println(outer) // OK
    println(inner) // OK
  }
  println(outer) // OK
  // println(inner) // エラー: inner はスコープ外
}
```

**不変性の利点:**

`let` による不変束縛をデフォルトとすることで、プログラムの特定の部分で値が変わらないことが保証されます。これにより、コードの可読性、予測可能性、そして特に並行処理における安全性が向上します。状態の変化を追跡する必要がある箇所が減り、プログラムの理解やデバッグが容易になります。

**`let` による関数定義:**

Protorun では、関数は `let` 束縛と関数式 ([6.3.3 関数式](06-expressions.md#633-関数式)) を組み合わせて定義します。これにより、関数も他の値と同様に扱われ、言語の一貫性が保たれます。

```protorun
// 基本的な関数定義
let add = fn (a: Int, b: Int): Int => a + b

// 型推論を利用
let square = fn x => x * x

// Effect パラメータを持つ関数
let log = fn (message: String) (effect console: Console): Unit => console.log(message)

// ジェネリック関数
let identity = fn <T> (x: T): T => x
```

**暗黙的な再帰:**

`let` で束縛された関数式は、自身の名前を再帰的に参照できます。特別なキーワード (`rec` など) は不要です。

```protorun
let factorial = fn (n: Int): Int => {
  if n <= 1 {
    1
  } else {
    n * factorial(n - 1) // 再帰呼び出し
  }
}
```

ただし、シャドウイングには注意が必要です。同じスコープ内で同名の変数を再束縛すると、意図しない動作を引き起こす可能性があります。

### 4.2.3 var宣言 (可変変数)

`var` 宣言は、新しい**可変**な変数を現在のスコープに導入します。`var` で宣言された変数は、後から代入演算子 (`=`) を使って新しい値を再代入することができます。

**構文:**

```ebnf
VarDeclaration ::= 'var' Identifier (':' Type)? '=' Expression
```

- `var`: 宣言を開始するキーワード。
- `Identifier`: 束縛する変数の名前。`let` と異なり、`var` は単一の識別子のみを受け付け、パターンによる分解束縛はできません。
- `(: Type)?`: **任意**の型注釈。省略された場合、型は右辺の `Expression` から推論されます。
- `= Expression`: 変数の初期値を計算する式。`var` 宣言でも**初期化は必須**です。

**意味:**

`var` 宣言は以下の動作を行います。

1. 右辺の `Expression` を評価します。
2. 評価結果の値を変数 `Identifier` に束縛します。
3. 束縛された名前は、宣言された時点から現在のスコープの終わりまで有効です。
4. 束縛された変数は可変であり、後から代入演算子 (`=`) を使って同じ型の別の値を代入することができます。

**具体例:**

```protorun
// 可変変数の宣言と初期化
var counter = 0 // 型は Int と推論される
var name: String = "Bob" // 型を明示的に指定

// 再代入
counter = counter + 1
name = "Charlie"

// counter = "error" // エラー: 型が異なる値は代入できない (String は Int ではない)

// スコープ
fn another_scope() {
  var mutable_value = 10
  println(mutable_value) // 10

  mutable_value = 20
  println(mutable_value) // 20

  {
    // var mutable_value = 30 // 内側スコープで同名の可変変数を宣言 (シャドウイング)
    let mutable_value = 30 // let でシャドウイングも可能
    println(mutable_value) // 30 (内側の変数)
  }
  println(mutable_value) // 20 (外側の変数)
}
```

**可変性の使用:**

Protorunでは不変性がデフォルトであり推奨されますが、アルゴリズムの実装（例: ループカウンター、状態の蓄積）や特定のデータ構造の効率的な更新など、可変性が必要となる場面もあります。`var` はそのような場合に、状態変化を伴うことを明示的に示すために使用されます。可変変数の使用は、プログラムのどの部分で状態が変化しうるかを理解する上で重要になるため、そのスコープを可能な限り小さく保つことが推奨されます。

## 4.3 型定義 // セクション番号を更新

Protorun言語では、`type` キーワードや `enum` キーワードを用いて、新しい型を定義したり、既存の型に別名を付けたりすることができます。これにより、コードの抽象化レベルを高め、データ構造を明確に表現することが可能になります。

### 4.3.1 レコード型定義 (構造体) // セクション番号を更新

レコード型は、名前付きフィールドを持つ複合データ型を定義します。他の言語における構造体やオブジェクトに似ています。

```protorun
// レコード型（構造体）
type Person = {
  name: String,
  age: Int
}
```

**特徴:**

- **名前付きフィールド**: 各フィールドは名前と型を持ちます (`name: String`, `age: Int`)。
- **データ集約**: 関連するデータを一つの単位としてまとめることができます。
- **アクセス**: フィールドへのアクセスは通常、ドット記法 (`person.name`) で行われます（詳細は式の章を参照）。
- **型安全性**: レコードの生成やフィールドアクセスは型チェックされます。

レコード型は、アプリケーションのドメインモデル（例: ユーザー、製品、注文など）を表現するのに適しています。

### 4.3.2 代数的データ型定義 (enum) // セクション番号を更新

代数的データ型（ADT）は、複数の異なる可能性のある構造（ヴァリアント）を一つの型として定義する方法です。Protorunでは `enum` キーワードを使用します。各ヴァリアントは、それ自体がデータを持つことができます。

```protorun
// 代数的データ型（enum構文）
enum Option<T> {
  Some(T), // 値が存在する場合、その値 T を持つ
  None     // 値が存在しない場合
}

enum Result<T, E> {
  Ok(T),   // 成功した場合、値 T を持つ
  Err(E)   // 失敗した場合、エラー E を持つ
}

enum Shape {
  Circle(radius: Float),
  Rectangle(width: Float, height: Float)
}
```

**特徴:**

- **ヴァリアント**: 型が取りうる複数のケース（`Some`/`None`, `Ok`/`Err`, `Circle`/`Rectangle`）を定義します。
- **データ保持**: 各ヴァリアントは、関連するデータを持つことができます（例: `Some(T)`, `Circle(radius: Float)`）。
- **網羅性**: パターンマッチング（式の章で詳述）と組み合わせることで、コンパイラがすべての可能なケースを処理しているかチェックできます。これにより、コードの堅牢性が向上します。
- **表現力**: 状態、選択肢、結果など、プログラム内で発生しうる様々な状況を正確かつ型安全にモデル化できます。

代数的データ型は、特にエラーハンドリング (`Result`)、オプションの値 (`Option`)、状態機械、ツリー構造などの表現に強力です。

### 4.3.3 型エイリアス定義 // セクション番号を更新

型エイリアスは、既存の型に新しい名前（エイリアス）を付ける機能です。複雑な型名を単純化したり、特定の用途を示す意味のある名前を与えたりするのに役立ちます。

```protorun
// 型エイリアス
type UserId = Int
type StringMap<T> = Map<String, T>
type Point = (Float, Float)
```

**特徴:**

- **可読性向上**: `UserId` は単なる `Int` よりも意図が明確です。
- **簡潔性**: 複雑な型 `Map<String, T>` を `StringMap<T>` という短い名前で参照できます。
- **構造的等価性**: 型エイリアスは新しい型を作成するわけではありません。`UserId` は `Int` と完全に互換性があります。これは、単に既存の型に対する別名です。

型エイリアスは、特にジェネリック型や関数型など、型シグネチャが長くなりがちな場合にコードを整理し、理解しやすくするのに有効です。

## 4.4 効果インターフェース定義とハンドラ実装

効果インターフェース (`effect`) とハンドラ実装 (`handler`) は、代数的効果システムの中核となる宣言です。

```protorun
// 効果インターフェース定義
effect MyEffect {
  fn operation1(arg: Type1): ReturnType1
  // ...
}

// ハンドラ実装 (特定の型 MyHandler に対して MyEffect を実装)
// MyHandler は別途 type で定義され、状態を持つことができる
type MyHandler {
  let state: StateType
}
handler MyEffect for MyHandler {
  // 操作の実装
  let operation1 = fn (self, arg: Type1): ReturnType1 => {
    // self を通じて MyHandler インスタンスの state にアクセス
    // 継続 (resume) の処理
  }
  // ...
}
```

- **`effect`**: 計算効果が提供する操作のシグネチャ（インターフェース）を定義します。
- **`handler`**: 特定の型 (`MyHandler`) に対して、特定の効果インターフェース (`MyEffect`) の操作を実装します。ハンドラ実装自体は状態を持たず、操作対象の状態は実装対象の型 (`MyHandler`) のインスタンス (`self`) が保持します。

これらの宣言の詳細は [8. 代数的効果](08-algebraic-effects.md) で説明されています。

## 4.5 トレイト定義と実装 // セクション番号を更新

```
// トレイト定義
trait Show {
  fn show(self): String
}

// トレイト継承（単一継承のみ）
trait Eq {
  fn equals(self, other: Self): Bool
}

trait Ord: Eq {
  fn compare(self, other: Self): Int

  // デフォルト実装
  fn equals(self, other: Self): Bool = self.compare(other) == 0
}

// トレイト実装
impl Int: Show {
  fn show(self): String = self.toString()
}

// ジェネリックな実装
impl<T: Show> Option<T>: Show {
  fn show(self): String = match self {
    Option.Some(v) => s"Some(${v.show()})",
    Option.None => "None"
  }
}
```

Protorun言語のトレイトシステムは、以下の原則に基づいて設計されています：

1. **インターフェース抽象化**: 型の振る舞いを抽象化し、多相的なコードを書くことができます
2. **型安全な多相性**: トレイト制約により、ジェネリックコードの型安全性を保証します
3. **コード再利用**: デフォルト実装により、共通の機能を再利用できます
4. **単一継承**: 複雑さを抑えるために、トレイトの継承は単一継承のみをサポートします

トレイトシステムは、Haskellの型クラスとRustのトレイトからインスピレーションを得ています。特に：

- **単一継承の選択**: 多重継承の複雑さ（ダイヤモンド問題など）を避けるために、単一継承のみをサポートしています。これにより、型システムの複雑さを抑えつつ、必要な抽象化を実現しています。

- **デフォルト実装**: トレイトメソッドにデフォルト実装を提供できます。これにより、トレイトを実装する型の実装負担を軽減し、コードの再利用性を高めています。

- **ジェネリックな実装**: 型パラメータにトレイト制約を付けることで、型安全なジェネリックコードを書くことができます。これにより、型の抽象化と具体的な実装の分離が可能になります。
