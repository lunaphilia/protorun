# 4. 所有権システム

## 4.1 所有権システムの概要と目的

Protorun言語の所有権システムは、メモリ安全性とリソース管理を静的に保証するためのメカニズムです。このシステムは以下の目的で設計されています：

1. **メモリ安全性**: ガベージコレクションに依存せずに、メモリリーク、ダングリングポインタ、二重解放などの問題を防止します
2. **データ競合の防止**: 並行プログラミングにおけるデータ競合を静的に検出し、防止します
3. **予測可能なリソース管理**: リソースの獲得と解放のタイミングを明確にし、予測可能なパフォーマンスを実現します
4. **明示的な共有**: データの共有を明示的にし、意図しない副作用を防止します
5. **コンパイル時検証**: 実行時のオーバーヘッドなしに、これらの保証を提供します

所有権システムは、Rustの所有権モデルからインスピレーションを得ていますが、代数的効果システムと統合されており、より表現力豊かなリソース管理パターンを実現しています。

## 4.2 所有権

```
// 所有権の移動
fn take(v: Vec<Int>): Int = {
  // vの所有権がここに移動
  v.length
}

let vec = [1, 2, 3]
take(vec)
// ここでvecは使用不可
```

所有権の概念は、以下の原則に基づいて設計されています：

1. **一意な所有者**: 各値は一度に一つの変数によって所有されます
2. **所有権の移動**: 値を別の変数に代入したり、関数に渡したりすると、所有権が移動します
3. **スコープベースの解放**: 所有者がスコープを出ると、値は自動的に解放されます
4. **明示的な共有**: 値の共有は借用を通じて明示的に行われます

所有権システムの主な利点：

- **自動メモリ管理**: ガベージコレクションのオーバーヘッドなしに、メモリリークを防止します
- **予測可能なリソース解放**: リソースが解放されるタイミングが明確で予測可能です
- **コンパイル時検証**: メモリエラーはコンパイル時に検出され、実行時エラーを防止します

所有権の移動は、値のコピーを避け、効率的なメモリ使用を実現します。特に大きなデータ構造や管理型（リソース型）の場合、これは重要です。コンパイラは、移動後の変数の使用を検出し、コンパイルエラーを発生させることで、使用後解放（use-after-free）などの問題を防止します。

## 4.3 借用

```
// 不変借用
fn peek(v: &Vec<Int>): Int = {
  // vの参照のみを使用
  v.length
}

// 可変借用
fn modify(v: &mut Vec<Int>): Unit = {
  // vの可変参照を使用
  v.push(42)
}

let mut vec = [1, 2, 3]
peek(&vec)    // 不変借用
modify(&mut vec)  // 可変借用
```

借用システムは、以下の原則に基づいて設計されています：

1. **一時的なアクセス**: 借用は値への一時的なアクセスを提供し、所有権を移動しません
2. **不変借用と可変借用の区別**: 読み取り専用アクセス（不変借用）と読み書きアクセス（可変借用）を明示的に区別します
3. **借用の制約**: 同時に存在できる借用に制約を設けることで、データ競合を防止します
4. **ライフタイム検証**: 借用のライフタイムが所有者のライフタイムを超えないことを保証します

借用システムの主な利点：

- **効率的なデータ共有**: 値のコピーなしに、データを安全に共有できます
- **データ競合の防止**: 同時に複数の可変借用が存在することを禁止し、データ競合を防止します
- **参照の安全性**: 参照が無効になる前に使用されることを防止します

借用システムは、所有権システムを補完し、値のコピーを避けながら安全なデータ共有を実現します。不変借用と可変借用を区別することで、読み取り専用アクセスと読み書きアクセスを明示的に表現し、意図しない変更を防止します。また、借用の制約（同時に複数の可変借用を許可しない、可変借用と不変借用の共存を許可しないなど）により、データ競合を静的に防止します。

### 4.3.1 参照型の構文

参照型は、型の前に`&`（不変参照）または`&mut`（可変参照）を付けることで表現されます：

```
&T      // Tへの不変参照型
&mut T  // Tへの可変参照型
```

参照型は、型システムの一部として明示的に定義されており、所有権システムと型システムの統合を実現しています。参照型は、関数のパラメータ型、戻り値の型、変数の型注釈など、型が使用されるあらゆる場所で使用できます。

参照の作成は、式の前に`&`または`&mut`を付けることで行います：

```
&expr       // exprへの不変参照を作成
&mut expr   // exprへの可変参照を作成
```

参照の逆参照（dereference）は、参照の前に`*`を付けることで行います：

```
*ref        // refが指す値を取得
```

参照型は、所有権システムと型システムを統合する重要な要素であり、安全な参照と借用を型レベルで表現することを可能にします。

借用システムは、以下の原則に基づいて設計されています：

1. **一時的なアクセス**: 借用は値への一時的なアクセスを提供し、所有権を移動しません
2. **不変借用と可変借用の区別**: 読み取り専用アクセス（不変借用）と読み書きアクセス（可変借用）を明示的に区別します
3. **借用の制約**: 同時に存在できる借用に制約を設けることで、データ競合を防止します
4. **ライフタイム検証**: 借用のライフタイムが所有者のライフタイムを超えないことを保証します

借用システムの主な利点：

- **効率的なデータ共有**: 値のコピーなしに、データを安全に共有できます
- **データ競合の防止**: 同時に複数の可変借用が存在することを禁止し、データ競合を防止します
- **参照の安全性**: 参照が無効になる前に使用されることを防止します

借用システムは、所有権システムを補完し、値のコピーを避けながら安全なデータ共有を実現します。不変借用と可変借用を区別することで、読み取り専用アクセスと読み書きアクセスを明示的に表現し、意図しない変更を防止します。また、借用の制約（同時に複数の可変借用を許可しない、可変借用と不変借用の共存を許可しないなど）により、データ競合を静的に防止します。

## 4.4 ライフタイム

```
// ライフタイム注釈
fn longest<'a>(x: &'a str, y: &'a str): &'a str = {
  if x.length > y.length { x } else { y }
}

// 構造体でのライフタイム
type Ref<'a, T> = {
  value: &'a T
}
```

ライフタイムシステムは、以下の原則に基づいて設計されています：

1. **参照の有効性保証**: 参照が指す値が有効である期間（ライフタイム）を追跡します
2. **ライフタイム関係の検証**: 参照のライフタイムが適切な関係を満たすことを検証します
3. **ライフタイム省略**: 多くの場合、ライフタイム注釈を省略できるようにし、コードの簡潔さを向上させます
4. **ジェネリックライフタイム**: 異なるライフタイムを持つ値に対して汎用的なコードを書けるようにします

ライフタイムシステムの主な利点：

- **ダングリングポインタの防止**: 参照が無効になった後に使用されることを防止します
- **参照の安全な保存**: 構造体やコンテナ内に参照を安全に保存できます
- **コンパイル時検証**: ライフタイムの関係はコンパイル時に検証され、実行時エラーを防止します

ライフタイム注釈は、コンパイラが自動的に推論できない場合に、参照のライフタイム関係を明示的に指定するためのものです。例えば、関数が複数の参照を受け取り、参照を返す場合、返される参照のライフタイムがどの入力参照のライフタイムに依存するかを指定する必要があります。

ライフタイムシステムは、所有権システムと借用システムを補完し、参照の安全性を保証します。これにより、ガベージコレクションに依存せずに、メモリ安全性を実現します。

## 4.5 リソース管理

Protorun言語では、リソース管理を効果システムと統合することで、安全で柔軟なリソース管理を実現しています。

```
// ライフサイクル管理効果を使用したリソース管理
effect FileSystem: LifecycleEffect<File> {
  fn acquire(): File = {
    File.open("example.txt")
  }
  
  fn release(file: File): Unit = {
    file.close()
  }
  
  fn read(): String
  fn write(content: String): Unit
}

// 使用例
fn processFile(): Result<String, IOError> & FileSystem = {
  // ファイルを開く（スコープ終了時に自動的に閉じられる）
  let file = FileSystem.acquire()
  
  // ファイルから読み込み
  let content = FileSystem.read()
  
  // 内容を処理
  let processed = processContent(content)
  
  Result.Ok(processed)
} // fileは自動的に閉じられる（FileSystem.release(file)が呼び出される）
```

リソース管理システムは、以下の原則に基づいて設計されています：

1. **確定的な解放**: リソースは所有者のスコープ終了時に確定的に解放されます
2. **RAII（Resource Acquisition Is Initialization）**: リソースの獲得は初期化時に行われ、解放は自動的に行われます
3. **型安全性**: リソース管理は型システムによって強制され、リソースリークを防止します
4. **例外安全性**: 例外が発生した場合でも、リソースは適切に解放されます

リソース管理システムの主な利点：

- **リソースリークの防止**: ファイルハンドル、ネットワーク接続、メモリなどのリソースのリークを防止します
- **予測可能な解放**: リソースが解放されるタイミングが明確で予測可能です
- **コードの簡潔さ**: 明示的な解放コードを書く必要がなく、コードの簡潔さが向上します

### 4.5.1 ライフサイクル管理効果によるリソース管理

リソース管理は、所有権システムとライフサイクル管理効果（`LifecycleEffect<R>`）を組み合わせて実現されます。ライフサイクル管理効果は、リソースの獲得（`acquire`）と解放（`release`）を明示的に定義し、効果ハンドラを通じて制御します。

ライフサイクル管理効果の詳細については、[5.4 ライフサイクル管理効果](05-algebraic-effects.md#54-ライフサイクル管理効果)を参照してください。

### 4.5.2 複数のリソースの管理

複数のリソースを管理する場合、それぞれのリソースは独立して獲得・解放されます：

```
// 複数のリソースを使用する例
fn processData(): Result<String, Error> & Database & FileSystem = {
  // データベース接続を獲得
  let conn = Database.acquire()
  
  // ファイルを開く
  let file = FileSystem.acquire()
  
  // データベースからデータを取得
  let data = Database.query("SELECT * FROM data")?
  
  // ファイルに書き込み
  FileSystem.write(data.toString())
  
  // ファイルから読み込み
  let content = FileSystem.read()
  
  Result.Ok(content)
} // conn と file は自動的に解放される（逆順）
```

複数のリソースが獲得された場合、それらは獲得された順序の逆順で解放されます。これにより、リソース間の依存関係がある場合でも、安全に解放されることが保証されます。
