# 4. 所有権システム

## 4.1 所有権システムの概要と目的

Protorun言語の所有権システムは、メモリ安全性とリソース管理を静的に保証するためのメカニズムです。このシステムは以下の目的で設計されています：

1. **メモリ安全性**: ガベージコレクションに依存せずに、メモリリーク、ダングリングポインタ、二重解放などの問題を防止します
2. **データ競合の防止**: 並行プログラミングにおけるデータ競合を静的に検出し、防止します
3. **予測可能なリソース管理**: リソースの獲得と解放のタイミングを明確にし、予測可能なパフォーマンスを実現します
4. **明示的な共有**: データの共有を明示的にし、意図しない副作用を防止します
5. **コンパイル時検証**: 実行時のオーバーヘッドなしに、これらの保証を提供します

所有権システムは、Rustの所有権モデルからインスピレーションを得ていますが、代数的効果システムと統合されており、より表現力豊かなリソース管理パターンを実現しています。

## 4.2 所有権

```
// 所有権の移動
fn take(v: Vec<Int>): Int = {
  // vの所有権がここに移動
  v.length
}

let vec = [1, 2, 3]
take(vec)
// ここでvecは使用不可
```

所有権の概念は、以下の原則に基づいて設計されています：

1. **一意な所有者**: 各値は一度に一つの変数によって所有されます
2. **所有権の移動**: 値を別の変数に代入したり、関数に渡したりすると、所有権が移動します
3. **スコープベースの解放**: 所有者がスコープを出ると、値は自動的に解放されます
4. **明示的な共有**: 値の共有は借用を通じて明示的に行われます

所有権システムの主な利点：

- **自動メモリ管理**: ガベージコレクションのオーバーヘッドなしに、メモリリークを防止します
- **予測可能なリソース解放**: リソースが解放されるタイミングが明確で予測可能です
- **コンパイル時検証**: メモリエラーはコンパイル時に検出され、実行時エラーを防止します

所有権の移動は、値のコピーを避け、効率的なメモリ使用を実現します。特に大きなデータ構造や管理型（リソース型）の場合、これは重要です。コンパイラは、移動後の変数の使用を検出し、コンパイルエラーを発生させることで、使用後解放（use-after-free）などの問題を防止します。

## 4.3 借用

```
// 不変借用
fn peek(v: &Vec<Int>): Int = {
  // vの参照のみを使用
  v.length
}

// 可変借用
fn modify(v: &mut Vec<Int>): Unit = {
  // vの可変参照を使用
  v.push(42)
}

let mut vec = [1, 2, 3]
peek(&vec)    // 不変借用
modify(&mut vec)  // 可変借用
```

借用システムは、以下の原則に基づいて設計されています：

1. **一時的なアクセス**: 借用は値への一時的なアクセスを提供し、所有権を移動しません
2. **不変借用と可変借用の区別**: 読み取り専用アクセス（不変借用）と読み書きアクセス（可変借用）を明示的に区別します
3. **借用の制約**: 同時に存在できる借用に制約を設けることで、データ競合を防止します
4. **ライフタイム検証**: 借用のライフタイムが所有者のライフタイムを超えないことを保証します

借用システムの主な利点：

- **効率的なデータ共有**: 値のコピーなしに、データを安全に共有できます
- **データ競合の防止**: 同時に複数の可変借用が存在することを禁止し、データ競合を防止します
- **参照の安全性**: 参照が無効になる前に使用されることを防止します

借用システムは、所有権システムを補完し、値のコピーを避けながら安全なデータ共有を実現します。不変借用と可変借用を区別することで、読み取り専用アクセスと読み書きアクセスを明示的に表現し、意図しない変更を防止します。また、借用の制約（同時に複数の可変借用を許可しない、可変借用と不変借用の共存を許可しないなど）により、データ競合を静的に防止します。

## 4.4 ライフタイム

```
// ライフタイム注釈
fn longest<'a>(x: &'a str, y: &'a str): &'a str = {
  if x.length > y.length { x } else { y }
}

// 構造体でのライフタイム
type Ref<'a, T> = {
  value: &'a T
}
```

ライフタイムシステムは、以下の原則に基づいて設計されています：

1. **参照の有効性保証**: 参照が指す値が有効である期間（ライフタイム）を追跡します
2. **ライフタイム関係の検証**: 参照のライフタイムが適切な関係を満たすことを検証します
3. **ライフタイム省略**: 多くの場合、ライフタイム注釈を省略できるようにし、コードの簡潔さを向上させます
4. **ジェネリックライフタイム**: 異なるライフタイムを持つ値に対して汎用的なコードを書けるようにします

ライフタイムシステムの主な利点：

- **ダングリングポインタの防止**: 参照が無効になった後に使用されることを防止します
- **参照の安全な保存**: 構造体やコンテナ内に参照を安全に保存できます
- **コンパイル時検証**: ライフタイムの関係はコンパイル時に検証され、実行時エラーを防止します

ライフタイム注釈は、コンパイラが自動的に推論できない場合に、参照のライフタイム関係を明示的に指定するためのものです。例えば、関数が複数の参照を受け取り、参照を返す場合、返される参照のライフタイムがどの入力参照のライフタイムに依存するかを指定する必要があります。

ライフタイムシステムは、所有権システムと借用システムを補完し、参照の安全性を保証します。これにより、ガベージコレクションに依存せずに、メモリ安全性を実現します。

## 4.5 リソース管理

```
// リソース型を使用したリソース管理
fn processFile(path: String): Result<String, IOError> = {
  // ファイルを開く（スコープ終了時に自動的に閉じられる）
  let file = File.open(path)?
  
  // ファイルの内容を読み取る
  let content = file.read()?
  
  // 内容を処理
  let processed = processContent(content)
  
  Result.Ok(processed)
} // ここでfileのreleaseメソッド（close）が自動的に呼び出される
```

リソース管理システムは、以下の原則に基づいて設計されています：

1. **確定的な解放**: リソースは所有者のスコープ終了時に確定的に解放されます
2. **RAII（Resource Acquisition Is Initialization）**: リソースの獲得は初期化時に行われ、解放は自動的に行われます
3. **型安全性**: リソース管理は型システムによって強制され、リソースリークを防止します
4. **例外安全性**: 例外が発生した場合でも、リソースは適切に解放されます

リソース管理システムの主な利点：

- **リソースリークの防止**: ファイルハンドル、ネットワーク接続、メモリなどのリソースのリークを防止します
- **予測可能な解放**: リソースが解放されるタイミングが明確で予測可能です
- **コードの簡潔さ**: 明示的な解放コードを書く必要がなく、コードの簡潔さが向上します

リソース管理は、所有権システムと管理型（旧リソース型）を組み合わせて実現されます。管理型は、獲得関数（コンストラクタ）と解放関数（デストラクタ）を持ち、所有者のスコープ終了時に自動的に解放関数が呼び出されます。これにより、try-finally構文などの明示的なリソース管理コードを書く必要がなくなり、コードの簡潔さと安全性が向上します。

また、リソース管理システムは、代数的効果システムと統合されており、ライフサイクル管理効果（`effect : lifecycle`）を使用して、より柔軟なリソース管理パターンを実現することもできます。これにより、リソースの獲得と解放を効果として抽象化し、効果ハンドラを通じて制御することができます。
