# 2. 字句構造

## 2.1 字句構造の設計原則

Protorun言語の字句構造は、以下の原則に基づいて設計されています：

1.  **読みやすさ**: 構文は明確で読みやすく、コードの意図を明確に伝えるべきです
2.  **一貫性**: 類似の概念は類似の構文で表現し、学習と理解を容易にします
3.  **簡潔さ**: 冗長性を最小限に抑え、簡潔な表現を可能にします
4.  **明示性**: 重要な概念や操作は明示的に表現し、隠れた動作を避けます

## 2.2 キーワード

Protorun言語で使用されるキーワードは以下の通りです。これらのキーワードは予約されており、識別子として使用することはできません。

| キーワード      | 主な用途                                                     | 関連する文法ルール/章                                                                 |
| :-------------- | :----------------------------------------------------------- | :------------------------------------------------------------------------------------ |
| `bind`          | bind式で使用され、モナド的な操作の連鎖を表現します。         | `BindExpr` ([6. 式](06-expressions.md))                                               |
| `effect`        | 代数的効果を宣言します。                                     | `EffectDecl` ([8. 代数的効果](08-algebraic-effects.md))                               |
| `else`          | `if`式の偽の場合の分岐を示します。                           | `IfExpr` ([6. 式](06-expressions.md))                                                 |
| `enum`          | 列挙型（代数的データ型）を宣言します。                       | `EnumDecl` ([4. 宣言](04-declarations.md))                                            |
| `export`        | モジュールから宣言（関数、型など）をエクスポートします。       | `ExportDecl` ([9. モジュール](09-modules.md))                                         |
| `fn`            | 関数を宣言します。                                           | `FunctionDecl` ([4. 宣言](04-declarations.md))                                        |
| `for`           | コレクション内包表記で使用され、要素の反復を示します。         | `CollectionComprehensionExpr` ([6. 式](06-expressions.md))                            |
| `handler`       | 効果ハンドラを宣言します。                                   | `HandlerDecl` ([8. 代数的効果](08-algebraic-effects.md))                              |
| `if`            | 条件式を開始します。                                         | `IfExpr` ([6. 式](06-expressions.md))                                                 |
| `impl`          | トレイトの実装を宣言します。                                 | `ImplDecl` ([4. 宣言](04-declarations.md))                                            |
| `let`           | 不変（イミュータブル）な変数を束縛します。                   | `LetDecl` ([4. 宣言](04-declarations.md))                                             |
| `match`         | パターンマッチ式を開始します。                               | `MatchExpr` ([6. 式](06-expressions.md))                                              |
| `mut`           | 可変性（ミュータビリティ）を示します（例: `&mut`）。         | `TypeRef` ([3. 型システム](03-type-system.md))                                        |
| `noresume`      | 効果ハンドラ内で、操作が値を返さず再開しないことを示します。 | `HandlerFunction` ([8. 代数的効果](08-algebraic-effects.md))                          |
| `multiresume` | 効果ハンドラ内で、操作が複数回再開する可能性があることを示します。 | `HandlerFunction` ([8. 代数的効果](08-algebraic-effects.md))                          |
| `own`           | 所有権を持つ型を示します。                                   | `TypeRef` ([7. 所有権](07-ownership.md))                                              |
| `resume`        | 効果ハンドラ内で、操作の再開ポイントを示します。             | `HandlerFunction` ([8. 代数的効果](08-algebraic-effects.md))                          |
| `return`        | 現在の関数から値を返します。                                 | `ReturnStatement` ([5. 文](05-statements.md))                                         |
| `trait`         | トレイト（インターフェース）を宣言します。                   | `TraitDecl` ([4. 宣言](04-declarations.md))                                           |
| `type`          | 型エイリアスや新しい型（レコード型など）を宣言します。       | `TypeDecl` ([4. 宣言](04-declarations.md))                                            |
| `var`           | 可変（ミュータブル）な変数を束縛します。                     | `VarDecl` ([4. 宣言](04-declarations.md))                                             |
| `with`          | 暗黙的パラメータリストやwith式（効果ハンドラの適用）で使用します。 | `ImplicitParamList`, `WithExpr` ([8. 代数的効果](08-algebraic-effects.md), [6. 式](06-expressions.md)) |

Protorun言語のキーワードは、以下の原則に基づいて選択されています：

1.  **最小性**: 必要最小限のキーワードを使用し、言語の学習を容易にします
2.  **明確性**: 各キーワードは明確な目的を持ち、その役割が理解しやすいものを選びます
3.  **一貫性**: 関連する概念には関連するキーワードを使用し、言語の一貫性を保ちます

## 2.3 演算子と記号

Protorun言語で使用される演算子と記号は以下の通りです。

### 2.3.1 算術演算子

| 演算子 | 意味         |
| :----- | :----------- |
| `+`    | 加算         |
| `-`    | 減算、単項マイナス |
| `*`    | 乗算         |
| `/`    | 除算         |
| `%`    | 剰余         |

### 2.3.2 比較演算子

| 演算子 | 意味         |
| :----- | :----------- |
| `==`   | 等価         |
| `!=`   | 非等価       |
| `<`    | より小       |
| `>`    | より大       |
| `<=`   | 以下         |
| `>=`   | 以上         |

### 2.3.3 論理演算子

| 演算子 | 意味     |
| :----- | :------- |
| `&&`   | 論理積   |
| `||`   | 論理和   |
| `!`    | 論理否定 |

### 2.3.4 ビットワイズ演算子 (型制約でも使用)

| 演算子 | 意味                               |
| :----- | :--------------------------------- |
| `&`    | ビットAND、参照型、型制約のAND結合 |
| `|`    | ビットOR、型制約のOR結合           |

### 2.3.5 代入演算子

| 演算子 | 意味 |
| :----- | :--- |
| `=`    | 代入 |

### 2.3.6 メンバーアクセスとスコープ

| 演算子 | 意味           |
| :----- | :------------- |
| `.`    | メンバーアクセス |

*(注意: `::` スコープ解決演算子は現在の文法では定義されていません)*

### 2.3.7 関数、型、パターン関連

| 演算子/記号 | 意味                                       |
| :---------- | :----------------------------------------- |
| `->`        | 関数型定義、マップリテラルのキー/値区切り    |
| `=>`        | マッチ式のアーム区切り、ラムダ式の本体区切り |
| `:`         | 型注釈、トレイト継承指定                   |
| `<-`        | コレクション内包表記、bind式の束縛         |
| `_`         | ワイルドカードパターン                     |

### 2.3.8 パイプライン演算子

| 演算子 | 意味                                       |
| :----- | :----------------------------------------- |
| `|>`   | パイプライン演算子 (値を関数に渡す)        |
| `|>*`  | 関数合成演算子                             |
| `>>>`  | 効果パイプライン演算子 (効果を持つ関数用)  |
| `>>>*` | 効果関数合成演算子 (効果を持つ関数用)      |

これらのパイプライン演算子は、関数型プログラミングスタイルを支援し、データフローを明確にするために導入されています。

-   `x |> f` は `f(x)` と等価です。
-   `f |>* g` は `\x -> g(f(x))` と等価な新しい関数を生成します。
-   `>>>` と `>>>*` は代数的効果を扱う際の同様の操作を提供します。詳細は [8. 代数的効果](08-algebraic-effects.md) を参照してください。

### 2.3.9 区切り文字とグループ化

| 演算子/記号 | 意味                                                         |
| :---------- | :----------------------------------------------------------- |
| `,`         | リスト要素、パラメータ、ジェネリック引数などの区切り         |
| `;`         | *(注意: 文の区切りとしての`;`は現在の文法では使用されていません)* |
| `(` `)`     | 式のグループ化、タプル、パラメータリスト、関数呼び出し       |
| `{` `}`     | ブロック式、レコード型、トレイト/実装本体、エクスポートリスト、マップ/セットリテラル |
| `[` `]`     | 配列型、リストリテラル、コレクション内包表記                 |
| `#{` `}`    | セットリテラル                                               |

### 2.3.10 範囲演算子

| 演算子 | 意味 |
| :----- | :--- |
| `..`   | 範囲 |

*(注意: `...` 演算子は現在の文法では定義されていません)*

Protorun言語の演算子は、以下の原則に基づいて設計されています：

1.  **親しみやすさ**: 一般的なプログラミング言語で使用される演算子を採用し、学習障壁を低減します
2.  **表現力**: 関数型プログラミングに適した演算子（パイプライン演算子`|>`など）を提供し、表現力を向上させます
3.  **一貫性**: 演算子の優先順位と結合性は直感的で一貫したルールに従います (詳細は [6. 式](06-expressions.md) の演算子優先順位のセクションを参照)。

## 2.4 リテラル

リテラルは、ソースコード内で具体的な値を直接表現する方法です。Protorunは以下の種類のリテラルをサポートします。

### 2.4.1 整数リテラル

整数値を表現します。以下の形式が利用可能です。

*   **10進数**: `42`, `123`
*   **16進数**: `0xFF`, `0x1A` (プレフィックス `0x`)
*   **2進数**: `0b1010`, `0b11110000` (プレフィックス `0b`)
*   **桁区切り**: アンダースコア `_` を使用して数値を読みやすく区切ることができます (`1_000_000`, `0b1111_0000`)。区切り文字は値には影響しません。

*(注意: 8進数リテラル、型サフィックス (例: `42i32`) は現在の仕様ではサポートされていません)*

### 2.4.2 浮動小数点リテラル

浮動小数点数を表現します。

*   **通常表記**: `3.14`, `0.5`, `10.0`
*   **指数表記**: `1e10` (1 * 10^10), `1.2e-3` (1.2 * 10^-3)。`e` または `E` を使用できます。
*   **桁区切り**: 整数リテラルと同様にアンダースコア `_` を使用できます (`3.141_592`)。

*(注意: 型サフィックス (例: `3.14f64`) は現在の仕様ではサポートされていません)*

### 2.4.3 文字列リテラル

テキストデータを表現します。

*   **通常文字列**: ダブルクォート `"` で囲みます (`"hello"`)。
*   **複数行文字列**: 3つのダブルクォート `"""` で囲みます。改行を含めることができます。
    ```protorun
    let multi = """
    これは
    複数行の
    文字列です。
    """;
    ```
*   **エスケープシーケンス**: 文字列内ではバックスラッシュ `\` を使ったエスケープシーケンスが利用可能です。
    *   `\n`: 改行
    *   `\t`: タブ
    *   `\\`: バックスラッシュ自身
    *   `\"`: ダブルクォート
    *   `\u{XXXX}`: Unicodeコードポイント (例: `"\u{1F600}"` は 😀)

*(注意: Raw文字列 (エスケープシーケンスを解釈しない文字列) は現在の仕様ではサポートされていません)*

### 2.4.4 文字リテラル

単一のUnicode文字を表現します。シングルクォート `'` で囲みます。

*   **通常文字**: `'a'`, `'Z'`
*   **エスケープシーケンス**: 文字列リテラルと同様のエスケープシーケンスが利用可能です (`'\n'`, `'\t'`, `'\\'`, `'\''`, `'\u{1F600}'`)。

### 2.4.5 ブールリテラル

真偽値を表現します。

*   `true`: 真
*   `false`: 偽

### 2.4.6 単位リテラル

値が存在しないこと、または意味のある値がないことを示す特別なリテラルです。

*   `()`: ユニット値。値を返さない関数の戻り値型 (`Unit`) の唯一の値です。

### 2.4.7 コレクションリテラル

リスト、マップ、セットを直接記述するためのリテラルです。

*   **リストリテラル**: 角括弧 `[]` で囲み、要素をカンマ `,` で区切ります。
    ```protorun
    let list = [1, 2, 3];
    ```
*   **マップリテラル**: 波括弧 `{}` で囲み、キーと値を `->` でペアにし、各ペアをカンマ `,` で区切ります。
    ```protorun
    let map = {"one" -> 1, "two" -> 2};
    ```
*   **セットリテラル**: `#{` と `}` で囲み、要素をカンマ `,` で区切ります。
    ```protorun
    let set = #{1, 2, 3};
    ```
詳細は [6. 式](06-expressions.md) のコレクションリテラルのセクションを参照してください。

Protorun言語のリテラルは、以下の原則に基づいて設計されています：

1.  **読みやすさ**: 数値リテラルの桁区切り文字（`_`）や複数行文字列（`"""`）など、コードの読みやすさを向上させる機能を提供します。
2.  **表現力**: 16進数（`0xFF`）や2進数（`0b1010`）、指数表記、多様なコレクションリテラルなど、様々な表記法をサポートし、表現力を向上させます。
3.  **型安全性**: 各リテラルは明確な型を持ち、型システムと整合性があります。例えば、整数リテラルはデフォルトで特定の整数型（例: `i64`）に推論され、必要に応じて型注釈で明示できます。

注意: Protorun言語では`null`リテラルは存在しません。これは、nullポインタ例外という「10億ドルの間違い」を防ぐための設計決定です。値の存在/不在はOption型で表現し、型システムによって安全に処理されます。

## 2.5 コメント

```
// 単一行コメント

/*
 * 複数行
 * コメント
 */

/// ドキュメントコメント（関数や型の直前に記述）
```

Protorun言語のコメントは、以下の原則に基づいて設計されています：

1.  **親しみやすさ**: 一般的なプログラミング言語で使用されるコメント構文を採用し、学習障壁を低減します
2.  **ドキュメント統合**: ドキュメントコメント（`///`）を使用することで、コードとドキュメントを密接に統合し、ドキュメントの鮮度を保ちます
3.  **読みやすさ**: 複数行コメントにより、長い説明や一時的なコードの無効化を読みやすく表現できます

ドキュメントコメントは、言語のツールチェーンと統合されており、API文書の自動生成に使用されます。これにより、コードとドキュメントの一貫性が保たれ、開発者の生産性が向上します。
