# 3. 宣言

## 3.1 宣言の概要

Protorun言語における宣言は、プログラムの構成要素（変数、関数、型、トレイト、効果、ハンドラなど）を定義するための構文です。宣言は、名前とそれに紐づく実体（値、型、振る舞いなど）を導入します。

この章では、Protorunで利用可能な主要な宣言について説明します。

## 3.2 変数宣言

### 3.2.1 概要と設計原則

Protorunでは、`let` キーワードと `var` キーワードを用いて変数（名前付きの値やメモリ領域）を宣言します。

```protorun
// 不変変数（デフォルト）
let x = 42
let y: Int = 42

// 可変変数
var counter = 0
var name: String = "John"
```

変数宣言の設計は、以下の原則に基づいています：

1.  **不変性の優先**: デフォルトでは変数は不変（`let`）であり、これにより予測可能性と安全性が向上します。これは関数型プログラミングの原則に沿った設計です。不変性により、コードの理解と推論が容易になり、並行処理における安全性も向上します。
2.  **明示的な可変性**: 可変性が必要な場合は `var` キーワードで明示的に宣言します。これにより、状態が変化する箇所をコード上で明確に識別できます。
3.  **型推論**: 多くの場合、初期化式から変数の型が推論されるため、型注釈 (`: Type`) は省略可能です。これによりコードが簡潔になります。
4.  **静的型付け**: 型注釈を省略した場合でも、すべての変数はコンパイル時に明確な型を持ちます。これにより型安全性が保証され、実行時エラーを削減します。必要に応じて明示的に型を指定することも可能です。

以下のサブセクションでは、`let` 宣言と `var` 宣言についてさらに詳しく説明します。

### 3.2.2 let宣言 (不変束縛)

`let` 宣言は、新しい**不変**な名前束縛を現在のスコープに導入します。一度 `let` で束縛された名前は、同じスコープ内で再代入することはできません。

**構文:**

```ebnf
LetDeclaration ::= 'let' Pattern (':' Type)? '=' Expression
```

- `let`: 宣言を開始するキーワード。
- `Pattern`: 束縛する名前（または複数の名前）を指定するパターン。単純な識別子だけでなく、タプルやレコードの分解束縛も可能です。（パターンの詳細は [5. 式](05-expressions.md#56-パターンマッチング) を参照）
- `(: Type)?`: **任意**の型注釈。省略された場合、型は右辺の `Expression` から推論されます。明示的に型を指定することで、意図を明確にしたり、推論だけでは決定できない型を指定したりできます。
- `= Expression`: 束縛する値を計算する初期化式。`let` 宣言では**初期化は必須**です。

**意味:**

`let` 宣言は以下の動作を行います。

1.  右辺の `Expression` を評価します。
2.  評価結果の値と左辺の `Pattern` をマッチングさせます。
3.  マッチングが成功した場合、パターン内の各識別子が評価結果の値（またはその一部）に束縛されます。
4.  束縛された名前は、宣言された時点から現在のスコープの終わりまで有効です。
5.  束縛された名前は不変であり、後から別の値を代入することはできません。

**具体例:**

```protorun
// 単純な束縛
let message = "Hello" // 型は String と推論される
let count: Int = 100   // 型を明示的に指定

// count = 200 // エラー: let束縛は不変であり再代入できない

// パターンによる分解束縛
let point = (10, 20) // point は (Int, Int) 型と推論される
let (x, y) = point   // x に 10, y に 20 が束縛される

// レコードの分解束縛 (仮の構文)
// type Person = { name: String, age: Int }
// let person = Person { name: "Alice", age: 30 }
// let { name: person_name, age } = person // person_name に "Alice", age に 30 が束縛される

// 型注釈と初期化
let pi: Float = 3.14159
let maybe_value: Option<Int> = Some(42)

// スコープ
fn example_scope() {
  let outer = "Outer scope"
  {
    let inner = "Inner scope"
    println(outer) // OK
    println(inner) // OK
  }
  println(outer) // OK
  // println(inner) // エラー: inner はスコープ外
}
```

**不変性の利点:**

`let` による不変束縛をデフォルトとすることで、プログラムの特定の部分で値が変わらないことが保証されます。これにより、コードの可読性、予測可能性、そして特に並行処理における安全性が向上します。状態の変化を追跡する必要がある箇所が減り、プログラムの理解やデバッグが容易になります。

### 3.2.3 var宣言 (可変変数)

`var` 宣言は、新しい**可変**な変数を現在のスコープに導入します。`var` で宣言された変数は、後から代入演算子 (`=`) を使って新しい値を再代入することができます。

**構文:**

```ebnf
VarDeclaration ::= 'var' Identifier (':' Type)? '=' Expression
```

- `var`: 宣言を開始するキーワード。
- `Identifier`: 束縛する変数の名前。`let` と異なり、`var` は単一の識別子のみを受け付け、パターンによる分解束縛はできません。
- `(: Type)?`: **任意**の型注釈。省略された場合、型は右辺の `Expression` から推論されます。
- `= Expression`: 変数の初期値を計算する式。`var` 宣言でも**初期化は必須**です。

**意味:**

`var` 宣言は以下の動作を行います。

1.  右辺の `Expression` を評価します。
2.  評価結果の値を変数 `Identifier` に束縛します。
3.  束縛された名前は、宣言された時点から現在のスコープの終わりまで有効です。
4.  束縛された変数は可変であり、後から代入演算子 (`=`) を使って同じ型の別の値を代入することができます。

**具体例:**

```protorun
// 可変変数の宣言と初期化
var counter = 0 // 型は Int と推論される
var name: String = "Bob" // 型を明示的に指定

// 再代入
counter = counter + 1
name = "Charlie"

// counter = "error" // エラー: 型が異なる値は代入できない (String は Int ではない)

// スコープ
fn another_scope() {
  var mutable_value = 10
  println(mutable_value) // 10

  mutable_value = 20
  println(mutable_value) // 20

  {
    // var mutable_value = 30 // 内側スコープで同名の可変変数を宣言 (シャドウイング)
    let mutable_value = 30 // let でシャドウイングも可能
    println(mutable_value) // 30 (内側の変数)
  }
  println(mutable_value) // 20 (外側の変数)
}
```

**可変性の使用:**

Protorunでは不変性がデフォルトであり推奨されますが、アルゴリズムの実装（例: ループカウンター、状態の蓄積）や特定のデータ構造の効率的な更新など、可変性が必要となる場面もあります。`var` はそのような場合に、状態変化を伴うことを明示的に示すために使用されます。可変変数の使用は、プログラムのどの部分で状態が変化しうるかを理解する上で重要になるため、そのスコープを可能な限り小さく保つことが推奨されます。

## 3.3 関数定義

```
// 基本的な関数定義
fn add(a: Int, b: Int): Int = {
  a + b
}

// 単一式の場合は中括弧を省略可能
fn square(x: Int): Int = x * x

// 効果付き関数
fn log(message: String): Unit & Console = {
  Console.log(message)
}

// ジェネリック関数
fn identity<T>(x: T): T = x

// 複数のパラメータリスト（カリー化）
fn add(a: Int)(b: Int): Int = a + b
```

Protorun言語の関数定義は、以下の原則に基づいて設計されています：

1. **一等の値**: 関数は一等の値であり、変数に代入したり、他の関数に渡したりできます
2. **型安全性**: 関数のパラメータと戻り値の型は静的に型チェックされます
3. **効果の明示**: 関数が持つ副作用は型シグネチャに明示的に記述されます
4. **多相性**: ジェネリックパラメータにより、型に依存しない汎用的なコードを書くことができます
5. **簡潔性**: 単一式の関数は中括弧を省略でき、コードの簡潔さを向上させます

特に重要な特徴：

- **効果注釈**: 関数が持つ副作用を`&`演算子で明示することで、関数の振る舞いが明確になり、予期しない副作用を防止します。これは、純粋関数型プログラミングの原則と実用性のバランスを取るための設計決定です。

- **ジェネリック関数**: 型パラメータを使用することで、様々な型に対して動作する汎用的な関数を定義できます。これにより、コードの再利用性が向上し、型安全性を維持しながら抽象化が可能になります。

- **カリー化**: 複数のパラメータリストをサポートすることで、部分適用や関数合成などの関数型プログラミングパターンを自然に表現できます。これにより、より表現力豊かなコードを書くことができます。
