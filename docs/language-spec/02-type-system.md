# 3. 型システム

## 3.1 型システムの概要と目的

Protorun言語の型システムは、静的型付け、強力な型推論、代数的データ型、トレイト（型クラス）、および所有権を組み合わせた包括的なシステムです。この型システムは以下の目的で設計されています：

1. **安全性**: コンパイル時に型エラーを検出し、実行時エラーを防止します
2. **表現力**: 複雑な概念を型安全に表現するための豊富な機能を提供します
3. **抽象化**: コードの再利用と拡張を促進する抽象化メカニズムを提供します
4. **効率性**: 型消去と特殊化により、効率的なコード生成を可能にします
5. **推論可能性**: 明示的な型注釈を最小限に抑えつつ、型安全性を確保します

Protorun言語の型システムは、Hindley-Milner型推論をベースに、効果型、所有権型、トレイト制約を統合した拡張システムです。これにより、表現力と安全性のバランスを取りながら、使いやすさを実現しています。

## 3.2 基本型

```
Int, Float, Double, Bool, Char, String, Unit
```

Protorun言語の基本型は、以下の原則に基づいて設計されています：

1. **完全性**: プログラミングに必要な基本的なデータ型をすべて提供します
2. **一貫性**: 各型は明確な意味と操作を持ち、予測可能な動作をします
3. **安全性**: すべての型はnon-nullableであり、nullによる実行時エラーを防止します

特に、nullの排除は重要な設計決定です。これは、Tony Hoareが「10億ドルの間違い」と呼んだnullポインタ例外を防ぐためです。値の存在/不在はOption型で明示的に表現され、型システムによって安全に処理されます。これにより、実行時のnullチェックの必要性が減少し、コードの信頼性が向上します。

## 3.3 複合型

```
// 配列型
 [T]
 
 // 関数型
 (T1, T2, ..., Tn) -> R
 (T1, T2, ..., Tn) -> R & E

// オプション型（値の存在/不在を表現）
Option<T>

// 結果型（成功/失敗を表現）
Result<T, E>
```

Protorun言語の複合型は、以下の原則に基づいて設計されています：

1. **合成性**: 基本型から複雑な型を構築するための明確なメカニズムを提供します
2. **型安全性**: 複合型の操作は型チェックされ、型の整合性が保証されます
3. **表現力**: 様々なデータ構造と計算パターンを表現するための豊富な型を提供します

特に注目すべき点：

- **関数型の効果注釈**: 関数型には効果注釈（`& E`）を含めることができます。これにより、関数が持つ可能性のある副作用を型レベルで追跡し、型安全な効果制御を実現します。

- **Option型とResult型**: nullの代わりにOption型を使用し、例外の代わりにResult型を使用することで、エラー処理を型安全かつ明示的に行うことができます。これにより、エラーハンドリングの漏れを防ぎ、コードの堅牢性が向上します。

## 3.4 型定義

```
// レコード型（構造体）
type Person = {
  name: String,
  age: Int
}

// 代数的データ型（enum構文）
enum Option<T> {
  Some(T),
  None
}

enum Result<T, E> {
  Ok(T),
  Err(E)
}

// 型エイリアス
type StringMap<T> = Map<String, T>
```

Protorun言語の型定義機能は、以下の原則に基づいて設計されています：

1. **抽象化**: 複雑なデータ構造を抽象化し、意味のある名前で表現できます
2. **型安全性**: 定義された型は型チェックされ、型の整合性が保証されます
3. **表現力**: レコード型と代数的データ型により、様々なデータモデルを表現できます

特に重要な機能：

- **レコード型**: 名前付きフィールドを持つ構造体を定義できます。これにより、関連するデータをグループ化し、意味のある単位として扱うことができます。

- **代数的データ型（enum）**: 複数の異なるケースを持つデータ型を定義できます。これは、パターンマッチングと組み合わせて使用することで、型安全な条件分岐を実現します。代数的データ型は、ドメインモデルを正確に表現し、不正な状態を型レベルで排除するのに役立ちます。

- **型エイリアス**: 既存の型に新しい名前を付けることができます。これにより、コードの意図を明確にし、長い型名を簡潔に表現できます。

## 3.5 トレイト（インターフェース）

```
// トレイト定義
trait Show {
  fn show(self): String
}

// トレイト継承（単一継承のみ）
trait Eq {
  fn equals(self, other: Self): Bool
}

trait Ord: Eq {
  fn compare(self, other: Self): Int
  
  // デフォルト実装
  fn equals(self, other: Self): Bool = self.compare(other) == 0
}

// トレイト実装
impl Int: Show {
  fn show(self): String = self.toString()
}

// ジェネリックな実装
impl<T: Show> Option<T>: Show {
  fn show(self): String = match self {
    Option.Some(v) => s"Some(${v.show()})",
    Option.None => "None"
  }
}
```

Protorun言語のトレイトシステムは、以下の原則に基づいて設計されています：

1. **インターフェース抽象化**: 型の振る舞いを抽象化し、多相的なコードを書くことができます
2. **型安全な多相性**: トレイト制約により、ジェネリックコードの型安全性を保証します
3. **コード再利用**: デフォルト実装により、共通の機能を再利用できます
4. **単一継承**: 複雑さを抑えるために、トレイトの継承は単一継承のみをサポートします

トレイトシステムは、Haskellの型クラスとRustのトレイトからインスピレーションを得ています。特に：

- **単一継承の選択**: 多重継承の複雑さ（ダイヤモンド問題など）を避けるために、単一継承のみをサポートしています。これにより、型システムの複雑さを抑えつつ、必要な抽象化を実現しています。

- **デフォルト実装**: トレイトメソッドにデフォルト実装を提供できます。これにより、トレイトを実装する型の実装負担を軽減し、コードの再利用性を高めています。

- **ジェネリックな実装**: 型パラメータにトレイト制約を付けることで、型安全なジェネリックコードを書くことができます。これにより、型の抽象化と具体的な実装の分離が可能になります。

## 3.6 ライフサイクル管理効果

ライフサイクル管理効果は、リソースの獲得と解放を自動的に管理するための効果システムです。詳細は[5.4 ライフサイクル管理効果](05-algebraic-effects.md#54-ライフサイクル管理効果)を参照してください。

### 3.6.1 暗黙的パラメータとライフサイクル管理効果

ライフサイクル管理効果は、暗黙的パラメータとしても使用できます。これにより、依存性注入パターンを型安全かつ簡潔に実装できます。詳細は[5.8 暗黙的パラメータと効果システム](05-algebraic-effects.md#58-暗黙的パラメータと効果システム)を参照してください。
