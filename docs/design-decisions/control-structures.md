# 制御構造の設計決定：if式とmatch式

## 概要

Protorun言語では、条件分岐のための制御構造として、if式とmatch式の両方を提供することを決定しました。この文書では、その決定の背景、両構文の比較分析、および設計上の考慮点について説明します。

## 決定事項

- if式とmatch式の両方を言語仕様に含める
- 両方とも式として扱い、値を返すことができるようにする
- それぞれの構文が最適な用途を明確にドキュメント化する

## 比較分析

### if式の利点

1. **直感的な読みやすさ**
   - 単純な条件分岐では、if式の方が読みやすく直感的
   - 特に条件が単一の真偽値の場合、if式は自然な表現になる
   - 例: `if isValid { ... } else { ... }`

2. **複合条件の表現**
   - 論理演算子（&&, ||, !）を使った複合条件が自然に表現できる
   - 例: `if x > 0 && y < 10 || z == 0 { ... }`

3. **段階的な条件評価**
   - if-else if-elseチェーンによる段階的な条件評価が直感的
   - 例:
     ```
     if condition1 {
       // 処理1
     } else if condition2 {
       // 処理2
     } else {
       // デフォルト処理
     }
     ```

4. **プログラマーの習慣と期待**
   - 多くのプログラマーが慣れ親しんでいる構文であり、学習コストが低い
   - 他の言語からの移行がスムーズになる

5. **単純な条件分岐の簡潔さ**
   - 単一の条件に基づく分岐では、matchよりも簡潔に書ける

### match式の利点

1. **パターンマッチングの表現力**
   - 代数的データ型の分解と条件分岐を統合できる
   - 例: 
     ```
     match opt {
       Option.Some(value) => s"値: $value",
       Option.None => "値なし"
     }
     ```

2. **網羅性チェック**
   - コンパイラが全てのケースが処理されているかチェックできる
   - 特に代数的データ型（enum）の場合、漏れがないことを保証できる

3. **ガード条件の統合**
   - パターンとガード条件を組み合わせた複雑な条件分岐が可能
   - 例: `pattern if guard => expression`

4. **複数の値に基づく分岐**
   - タプルや複合パターンを使って複数の値に基づく分岐が簡潔に書ける
   - 例: 
     ```
     match (x, y) {
       (0, 0) => "原点",
       (0, _) => "x軸上",
       (_, 0) => "y軸上",
       _ => "その他"
     }
     ```

5. **関数型プログラミングとの親和性**
   - 関数型プログラミングのパラダイムと自然に調和する
   - 値に基づく分岐を式として扱える

## if式をmatch式で置き換える可能性の検討

### 置き換え例

1. **単純なif式**
   ```
   if condition {
     expr1
   } else {
     expr2
   }
   ```

   match式での表現:
   ```
   match condition {
     true => expr1,
     false => expr2
   }
   ```

2. **if-else ifチェーン**
   ```
   if condition1 {
     expr1
   } else if condition2 {
     expr2
   } else {
     expr3
   }
   ```

   match式での表現:
   ```
   match true {
     _ if condition1 => expr1,
     _ if condition2 => expr2,
     _ => expr3
   }
   ```

### 置き換えの問題点

1. **冗長性と読みにくさ**
   - 単純な条件分岐でmatch式を使うと冗長になる場合がある
   - 特に`match true { _ if ... }`のパターンは直感的でない

2. **短絡評価の扱い**
   - 論理演算子（&&, ||）の短絡評価の挙動がmatch式では直感的に表現しにくい

3. **複合条件の可読性**
   - 複雑な論理条件をガード条件として表現すると読みにくくなる場合がある

## 両方の構文を維持する理由

1. **用途に応じた適切なツール**
   - if式: 単純な条件分岐、複合論理条件
   - match式: パターンマッチング、代数的データ型の分解、網羅的な条件分岐

2. **表現力と読みやすさのバランス**
   - 両方の構文を提供することで、状況に応じて最も読みやすく表現力のある方を選択できる

3. **他の言語との互換性**
   - 多くの現代的な言語（Rust, Scala, Swift等）も両方の構文を提供している
   - 学習コストと移行のしやすさを考慮すると、両方を提供する価値がある

4. **言語の一貫性**
   - 関数型と命令型のパラダイムを統合する言語として、両方のスタイルをサポートすることで一貫性が保たれる

## 設計上の考慮点

1. **if式の拡張可能性**
   - 将来的に、if式にパターンマッチング機能を追加することも検討可能
   - 例: `if let Some(value) = option { ... }` (Rustスタイル)

2. **構文の一貫性**
   - 両方の構文を維持する場合、式としての一貫した振る舞いを保証することが重要
   - 両方とも値を返す式として扱えるようにする

3. **コンパイラの実装**
   - 内部的には似た表現にすることで、コンパイラの複雑さを軽減
   - 両方の構文に対して同様の最適化を適用できるようにする

4. **エラーメッセージ**
   - わかりやすく一貫性のあるエラーメッセージを提供

## 推奨される使用パターン

### if式の推奨用途

- 単純な真偽値条件に基づく分岐
- 複合論理条件（&&, ||, !を使った条件）
- 段階的な条件評価（if-else ifチェーン）
- 命令型プログラミングスタイルの表現

### match式の推奨用途

- 代数的データ型（enum）の分解
- パターンに基づく分岐
- 網羅性が重要な場合（コンパイラによる網羅性チェック）
- 複数の値に基づく分岐（タプルパターンなど）

## 結論

Protorun言語において、if式とmatch式はそれぞれ異なる強みと用途を持っています。match式だけでも条件分岐は表現できますが、if式を残すことで言語の表現力と使いやすさが向上します。両方の構文を維持することで、プログラマーは状況に応じて最適な表現を選択できるようになります。

これらの構文は競合するものではなく、相補的な役割を果たし、言語全体の表現力を高めることになります。
